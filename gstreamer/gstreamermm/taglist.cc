// Generated by gtkmmproc -- DO NOT MODIFY!


#include <gstreamermm/taglist.h>
#include <gstreamermm/private/taglist_p.h>

// -*- Mode: C++; indent-tabs-mode: nil; c-basic-offset: 2 -*-

/* gstreamermm - a C++ wrapper for gstreamer
 *
 * Copyright 2008 The gstreamermm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gst/gstenumtypes.h>

/*
static gboolean
TagList_Foreach_gstreamermm_callback(const GstTagList* list, const gchar *tag, void* data)
{
  Gst::TagList::SlotForeach* slot = static_cast<Gst::TagList::SlotForeach*>(data);
  bool result = (*slot)(Glib::wrap(list), Glib::ustring(value));
  delete slot;
  return result;
}
*/

namespace Gst
{

/*
void
TagList::foreach(const SlotForeach& slot)
{
  SlotForeach* slot_copy = new SlotForeach(slot);
  gst_taglist_foreach(gobj(), &TagList_Foreach_gstreamermm_callback, slot_copy);
}
*/

} //namespace Gst

namespace
{
} // anonymous namespace

// static
GType Glib::Value<Gst::TagMergeMode>::value_type()
{
  return gst_tag_merge_mode_get_type();
}

// static
GType Glib::Value<Gst::TagFlag>::value_type()
{
  return gst_tag_flag_get_type();
}


namespace Glib
{

Gst::TagList wrap(GstTagList* object, bool take_copy, bool destroy, bool dummy)
{
  return Gst::TagList(object, take_copy, destroy);
}

} // namespace Glib


namespace Gst
{


// static
GType TagList::get_type()
{
  return gst_tag_list_get_type();
}

TagList::TagList()
:
  gobject_ (gst_tag_list_new())
{}

TagList::TagList(const TagList& other)
:
  gobject_ (other.gobject_),  // Always use original object
  destroy(false)  // Do not delete gobject when wrapper is destroyed (let
                  // original wrapper do that)
{}

TagList::TagList(GstTagList* gobject, bool make_a_copy, bool destroy)
:
  // For this ncopy extra BoxedType wrapper, make_a_copy is false by default
  // and destroy is true.
  gobject_ ((make_a_copy && gobject) ? gst_tag_list_copy(gobject) : gobject),
  destroy(destroy) // Should wrapper destroy gobject when deleted?
{}

// operator=() DOES make copies of gobject.
TagList& TagList::operator=(const TagList& other)
{
  TagList temp (gobject_, true);
  swap(temp);
  return *this;
}

TagList::~TagList()
{
  if(destroy && gobject_)
    gst_tag_list_free(gobject_);
}

void TagList::swap(TagList& other)
{
  GstTagList *const temp = gobject_;
  gobject_ = other.gobject_;
  other.gobject_ = temp;

  bool const destroy_temp = destroy;
  destroy = other.destroy;
  other.destroy = destroy_temp;
}

GstTagList* TagList::gobj_copy() const
{
  return gst_tag_list_copy(gobject_);
}

//
void TagList::set_destroy(bool destroy)
{
  this->destroy = destroy;
}


bool TagList::exists(const Glib::ustring& tag)
{
  return gst_tag_exists(tag.c_str());
}


GType TagList::get_type(const Glib::ustring& tag)
{
  return gst_tag_get_type(tag.c_str());
}


Glib::ustring TagList::get_nick(const Glib::ustring& tag)
{
  return Glib::convert_const_gchar_ptr_to_ustring(gst_tag_get_nick(tag.c_str()));
}


Glib::ustring TagList::get_description(const Glib::ustring& tag)
{
  return Glib::convert_const_gchar_ptr_to_ustring(gst_tag_get_description(tag.c_str()));
}


TagFlag TagList::get_flag(const Glib::ustring& tag)
{
  return (TagFlag)(gst_tag_get_flag(tag.c_str()));
}


bool TagList::is_fixed(const Glib::ustring& tag)
{
  return gst_tag_is_fixed(tag.c_str());
}


bool TagList::empty()
{
  return gst_tag_list_is_empty(gobj());
}

void TagList::insert(const TagList& other, TagMergeMode mode)
{
gst_tag_list_insert(gobj(), ((other).gobj()), ((GstTagMergeMode)(mode))); 
}

TagList TagList::merge(const TagList& other, TagMergeMode mode)
{
  return Glib::wrap(gst_tag_list_merge(gobj(), ((other).gobj()), ((GstTagMergeMode)(mode))));
}


} // namespace Gst


