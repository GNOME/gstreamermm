// -*- Mode: C++; indent-tabs-mode: nil; c-basic-offset: 2 -*-

/* gstreamermm - a C++ wrapper for gstreamer
 *
 * Copyright 2008 The gstreamermm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gst/gstquery.h>
#include <gstreamermm/miniobject.h>
#include <gstreamermm/structure.h>
#include <gstreamermm/wrap.h>
#include <gstreamermm/format.h>

_DEFS(gstreamermm,gst)

namespace Gst
{

_WRAP_ENUM(QueryType, GstQueryType)

Glib::ustring get_name(QueryType t);
Glib::QueryQuark get_quark(QueryType t);

struct QueryTypeDefinition
{
  QueryType             value;
  Glib::ustring         nick;
  Glib::ustring         description;
  Glib::QueryQuark      quark;
};

class Query : public MiniObject
{
protected:
  _CLASS_GSTMINIOBJECT(Query, GstQuery, GST_QUERY, Gst::MiniObject, GstMiniObject)

public:
  /** Get the structure of a query.
   * @return The Structure of the query (unmodifiable)
   */
  const Structure* get_structure();

public:
  _MEMBER_GET(query_type, type, QueryType, GstQueryType)

  /** Wrap a GstQuery* in a C++ instance, creating an instance of a derived
   * Gst::Query. Gst::wrap() would just create a Gst::Query (rather than a
   * derived one) because the derived Gst::Query classes do not correspond
   * to GType types in the GStreamer API.
   */
  static Glib::RefPtr<Query> wrap(GstQuery* query, bool take_copy=false);

  _WRAP_METHOD(static QueryType register_query_type(const Glib::ustring& nick, const Glib::ustring& description), gst_query_type_register)
  _WRAP_METHOD(static QueryType get_query_type(const Glib::ustring& nick), gst_query_type_get_by_nick)
  _WRAP_METHOD(static bool query_types_contains(const Glib::ArrayHandle<QueryType>& types, QueryType type), gst_query_types_contains)

  bool get_details(QueryType type, QueryTypeDefinition& def);
};

class QueryConvert : public Query
{
public:
  explicit QueryConvert(GstQuery* query);

  static Glib::RefPtr<Query> create(Format src_format, gint64 value, Format dest_format);
  void set(Format src_format, gint64 src_value, Format dest_format, gint64 dest_value);
  void parse(Format& dest_format, gint64& dest_value);
  void parse(Format& src_format, gint64& src_value, Format& dest_format, gint64& dest_value);
};

class QueryPosition : public Query
{
public:
  explicit QueryPosition(GstQuery* query);

  static Glib::RefPtr<Query> create(Format format);
  void set(Format format, gint64 position);
  void parse(Format& format, gint64& position);
};

class QueryDuration : public Query
{
public:
  explicit QueryDuration(GstQuery* query);

  static Glib::RefPtr<Query> create(Format format);
  void set(Format format, gint64 duration);
  void parse(Format& format, gint64& duration);
};

class QueryLatency : public Query
{
public:
  explicit QueryLatency(GstQuery* query);

  static Glib::RefPtr<Query> create();
  void set(bool live, ClockTime min_latency, ClockTime max_latency);
  void parse(bool& live, ClockTime& min_latency, ClockTime& max_latency);
};

class QuerySeeking : public Query
{
public:
  explicit QuerySeeking(GstQuery* query);

  static Glib::RefPtr<Query> create(Format format);
  void set(Format format, bool seeakable, gint64 segment_start, gint64 segment_end);
  void parse(Format& format, bool& seekable, gint64& segment_start, gint64& segment_end);
};

class QueryFormats : public Query
{
public:
  explicit QueryFormats(GstQuery* query);

  static Glib::RefPtr<Query> create();
  void set(int n_formats, const va_list& varargs);
  //TODO: set(int n_formats, const std::vector<const Format>& formats);
  void parse(guint& n_formats);
  void parse(guint nth, Format& format);
};

class QuerySegment : public Query
{
public:
  explicit QuerySegment(GstQuery* query);

  static Glib::RefPtr<Query> create(Format format);
  void set(double rate, Format format, gint64 start_value, gint64 stop_value);
  void parse(double& rate, Format& format, gint64& start_value, gint64& stop_value);
};

} //namespace Gst
