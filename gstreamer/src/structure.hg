// -*- Mode: C++; indent-tabs-mode: nil; c-basic-offset: 2 -*-

/* gstreamermm - a C++ wrapper for gstreamer
 *
 * Copyright 2008 The gstreamermm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gstreamermm/clock.h>
#include <gstreamermm/enums.h>
#include <gstreamermm/value.h>

_DEFS(gstreamermm,gst)

namespace Gst
{

/** Gst::Structure â€” Generic structure containing fields of names and values.
 * A Gst::Structure is a collection of key/value pairs. The keys are expressed
 * as GQuarks and the values can be of any GType.
 *
 * In addition to the key/value pairs, a Gst::Structure also has a name. The
 * name starts with a letter and can be folled by letters, numbers and any of
 * "/-_.:".
 *
 * Gst::Structure is used by various GStreamer subsystems to store information
 * in a flexible and extensible way. A Gst::Structure does not have a refcount
 * because it usually is part of a higher level object such as Gst::Caps. It
 * provides a means to enforce mutability using the refcount of the parent.
 *
 * Last reviewed on 2007-10-16 (0.10.15)
 */
class Structure
{
 _CLASS_BOXEDTYPE(Structure, GstStructure, NONE, gst_structure_copy, gst_structure_free)
public:

  explicit Structure(const Glib::ustring& name);

  /** Use this to discover if the Structure is a valid object.
   */
  operator bool() const;

  _WRAP_METHOD(Glib::ustring get_name() const, gst_structure_get_name)
  _WRAP_METHOD(bool has_name(const Glib::ustring& name) const, gst_structure_has_name)
  _WRAP_METHOD(void set_name(const Glib::ustring& name), gst_structure_set_name)
  _WRAP_METHOD(Glib::QueryQuark get_name_id() const, gst_structure_get_name_id)

  /** Get the value of the field with name fieldname.
   *
   * @param fieldname the name of the field to get
   * @param value the Value class in which to store the value
   */
  void get_field(const Glib::ustring& fieldname, Glib::ValueBase& value) const;

  /** Sets the field with the given name field to value. If the field does not
   * exist, it is created. If the field exists, the previous value is replaced
   * and freed. Returns this Gst::Structure for continued setting convenience.
   * Please note that when setting special GStreamer fields such as
   * Glib::Value<Gst::IntRange> and Glib::Value<Gst::Fraction> (using classes
   * in value.h) they are converted to the GStreamer GTypes and thus when
   * attempting to get these fields back, they can no longer be stored in the
   * same Glib::Value<...>.
   *
   * @param fieldname the name of the field to set
   * @param value the new value of the field 
   * @return this Gst::Structure
   */
  Structure& set_field(const Glib::ustring& fieldname, const Glib::ValueBase& value);

  //Only for use inside gstreamermm:
  static void _set_gstructure_field(GstStructure* cstructure, const Glib::ustring& fieldname, const Glib::ValueBase& value);

  /** Removes the field with the given name. If the field with the given name
   * does not exist, the structure is unchanged. Returns this Gst::Structure
   * for continued setting convenience.
   *
   * @param fieldname the name of the field to remove
   * @return this Gst::Structure
   */
  Structure& remove_field(const Glib::ustring& fieldname);

  _WRAP_METHOD(void remove_all_fields(), gst_structure_remove_all_fields)
  _WRAP_METHOD(GType get_field_type(const Glib::ustring& fieldname) const, gst_structure_get_field_type)

  /** For example,
   * bool on_foreach(const Glib::QueryQuark& id, const Glib::ValueBase& value);
   * The foreach function should return true if foreach operation should
   * continue, false if operation should stop with false.
   */
  typedef sigc::slot<bool, const Glib::QueryQuark&, const Glib::ValueBase&> SlotForeach;

  /** Calls the provided slot once for each field in the Gst::Structure. The
   * slot must not modify the fields. Also see map_in_place().
   *
   * @param slot a slot to call for each field
   * @return TRUE if the supplied slot returns TRUE For each of the fields,
   * false otherwise.
   */
  bool foreach(const SlotForeach& slot);

  _WRAP_METHOD(int size() const, gst_structure_n_fields)
  _WRAP_METHOD(bool has_field(const Glib::ustring& fieldname) const, gst_structure_has_field)
  _WRAP_METHOD(bool has_field(const Glib::ustring& fieldname, GType type) const, gst_structure_has_field_typed)

  /** Sets the GValue of value to the boolean value of the given field. Caller
   * is responsible for making sure the field exists and has the correct type.
   *
   * @param fieldname the name of a field
   * @param value the Value class to set
   * @return TRUE if the value could be set correctly. If there was no field
   * with fieldname or the existing field did not contain a boolean, this
   * function returns false.
   */
  bool get_boolean(const Glib::ustring& fieldname, Glib::ValueBase& value) const;

  /** Sets the GValue of value to the int value of the given field. Caller
   * is responsible for making sure the field exists and has the correct type.
   *
   * @param fieldname the name of a field
   * @param value the Value class to set
   * @return TRUE if the value could be set correctly. If there was no field
   * with fieldname or the existing field did not contain an int, this function
   * returns false returns false
   */
  bool get_int(const Glib::ustring& fieldname, Glib::ValueBase& value) const;

  /** Sets the GValue of value to the uint value of the given field. Caller
   * is responsible for making sure the field exists and has the correct type.
   *
   * @param fieldname the name of a field
   * @param value the Value class to set
   * @return TRUE if the value could be set correctly. If there was no field
   * with fieldname or the existing field did not contain an uint, this
   * function returns false returns false
   */
  bool get_uint(const Glib::ustring& fieldname, Glib::ValueBase& value) const;

  /** Sets the GValue of value to the fourc value of the given field. Caller
   * is responsible for making sure the field exists and has the correct type.
   *
   * @param fieldname the name of a field
   * @param value the Value class to set
   * @return TRUE if the value could be set correctly. If there was no field
   * with fieldname or the existing field did not contain a fourc, this
   * function returns false returns false
   */
  bool get_fourcc(const Glib::ustring& fieldname, Glib::ValueBase& value) const;

  /** Sets the GValue of value to the double value of the given field. Caller
   * is responsible for making sure the field exists and has the correct type.
   *
   * @param fieldname the name of a field
   * @param value the Value class to set
   * @return TRUE if the value could be set correctly. If there was no field
   * with fieldname or the existing field did not contain a double, this
   * function returns false returns false
   */
  bool get_double(const Glib::ustring& fieldname, Glib::ValueBase& value) const;

  /** Sets the GValue of value to the string value of the given field. Caller
   * is responsible for making sure the field exists and has the correct type.
   *
   * @param fieldname the name of a field
   * @param value the Value class to set
   * @return TRUE if the value could be set correctly. If there was no field
   * with fieldname or the existing field did not contain a string, this
   * function returns false returns false
   */
  bool get_string(const Glib::ustring& fieldname, Glib::ValueBase& value) const;

  /** Sets the GValue of value to the GDate value of the given field. Caller
   * is responsible for making sure the field exists and has the correct type.
   *
   * @param fieldname the name of a field
   * @param date the Glib::Date class to set
   * @return TRUE if the value could be set correctly. If there was no field
   * with fieldname or the existing field did not contain a GDate, this
   * function returns false returns false
   */
  bool get_date(const Glib::ustring& fieldname, Glib::Date& value) const;

  /** Sets the GValue of value to the Gst::ClockTime value of the given field.
   * Caller is responsible for making sure the field exists and has the correct
   * type.
   *
   * @param fieldname the name of a field
   * @param value the Value class to set
   * @return TRUE if the value could be set correctly. If there was no field
   * with fieldname or the existing field did not contain a Gst::ClockTime,
   * this function returns false returns false
   */
  bool get_clock_time(const Glib::ustring& fieldname, Glib::ValueBase& value) const;

  /** Sets the GValue of value to the enum value of the given field. Caller
   * is responsible for making sure the field exists and has the correct type.
   *
   * @param fieldname the name of a field
   * @param value the Value class to set
   * @return TRUE if the value could be set correctly. If there was no field
   * with fieldname or the existing field did not contain a enum, this
   * function returns false returns false
   */
  bool get_enum(const Glib::ustring& fieldname, GType enumtype, Glib::ValueBase& value) const;

  /** Sets the GValue of value to the Gst::Fraction value of the given field.
   * Caller is responsible for making sure the field exists and has the correct
   * type.
   *
   * @param fieldname the name of a field
   * @param fraction the Gst::Fraction class to set
   * @return TRUE if the value could be set correctly. If there was no field
   * with fieldname or the existing field did not contain a Gst::Fraction, this
   * function returns false returns false
   */
  bool get_fraction(const Glib::ustring& fieldname, Gst::Fraction& fraction) const;

  /** For example,
   * bool on_map(const Glib::QueryQuark& id, Glib::ValueBase& value);
   * The map function should return true if map operation should continue,
   * false if operation should stop with false.
   */
  typedef sigc::slot<bool, const Glib::QueryQuark&, Glib::ValueBase&> SlotMap;

  /** Calls the provided slot once for each field in the Gst::Structure. In
   * contrast to foreach(), the function may modify but not delete the fields.
   * The structure must be mutable.
   *
   * @param slot a slot to call for each field
   * @return TRUE if the supplied slot returns TRUE For each of the fields,
   * false otherwise.
   */
  bool map_in_place(const SlotMap& slot);

  _WRAP_METHOD(Glib::ustring get_nth_field_name(guint index) const, gst_structure_nth_field_name)
  _WRAP_METHOD(Glib::ustring to_string() const, gst_structure_to_string)

  static Structure create_from_string(const Glib::ustring& the_string);

  _IGNORE(
      gst_structure_get_date,
      gst_structure_id_set,
      gst_structure_id_get_value,
      gst_structure_remove_fields_valist,
      gst_structure_fixate_field_boolean,
      gst_structure_id_set_value,
      gst_structure_get_enum,
      gst_structure_get_clock_time,
      gst_structure_remove_all_fields,
      gst_structure_get_fraction,
      gst_structure_remove_field,
      gst_structure_has_field_typed,
      gst_structure_get_string,
      gst_structure_fixate_field_nearest_int,
      gst_structure_fixate_field_nearest_double,
      gst_structure_remove_fields,
      gst_structure_copy,
      gst_structure_id_set_valist,
      gst_structure_get_field_type,
      gst_structure_map_in_place,
      gst_structure_get_value,
      gst_structure_free,
      gst_structure_n_fields,
      gst_structure_get_double,
      gst_structure_get_boolean,
      gst_structure_has_field,
      gst_structure_set,
      gst_structure_get_fourcc,
      gst_structure_set_value,
      gst_structure_foreach,
      gst_structure_fixate_field_nearest_fraction,
      gst_structure_set_valist,
      gst_structure_set_parent_refcount,
      gst_structure_get_int,
      gst_structure_get_uint)

};

} //namespace Gst
