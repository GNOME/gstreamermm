// -*- Mode: C++; indent-tabs-mode: nil; c-basic-offset: 2 -*-

/* gstreamermm - a C++ wrapper for gstreamer
 *
 * Copyright 2008 The gstreamermm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gst/gstbus.h>
#include <gstreamermm/object.h>
#include <gstreamermm/clock.h>
#include <gstreamermm/message.h>

_DEFS(gstreamermm,gst)
_PINCLUDE(glibmm/private/object_p.h)
_PINCLUDE(gstreamermm/private/object_p.h)

namespace Gst
{

class Message;

_WRAP_ENUM(BusFlags, GstBusFlags)
_WRAP_ENUM(BusSyncReply, GstBusSyncReply)

//TODO: Correct C API reference in class docs below:

/** Bus â€” Asynchronous message bus subsystem.
 * The Bus is an object responsible for delivering Messages in a first-in
 * first-out way from the streaming threads to the application.
 *
 * Since the application typically only wants to deal with delivery of these
 * messages from one thread, the Bus will marshall the messages between
 * different threads. This is important since the actual streaming of media is
 * done in another thread than the application.
 *
 * The Bus provides support for GSource based notifications. This makes it
 * possible to handle the delivery in the glib mainloop.
 *
 * The GSource callback function gst_bus_async_signal_func() can be used to
 * convert all bus messages into signal emissions.
 *
 * A message is posted on the bus with the post() method. With the peek() and
 * pop() methods one can look at or retrieve a previously posted message.
 *
 * The bus can be polled with the poll() method. This methods blocks up to the
 * specified timeout value until one of the specified messages types is posted
 * on the bus. The application can then _pop() the messages from the bus to
 * handle them. Alternatively the application can register an asynchronous bus
 * function using add_watch(). This function will install a GSource in the
 * default glib main loop and will deliver messages a short while after they
 * have been posted. Note that the main loop should be running for the
 * asynchronous callbacks.
 *
 * It is also possible to get messages from the bus without any thread
 * marshalling with the gst_bus_set_sync_handler() method. This makes it
 * possible to react to a message in the same thread that posted the message on
 * the bus. This should only be used if the application is able to deal with
 * messages from different threads.
 *
 * Every Pipeline has one bus.
 *
 * Note that a Pipeline will set its bus into flushing state when changing from
 * READY to NULL state.
 *
 * Last reviewed on 2006-03-12 (0.10.5)
 */
class Bus : public Object
{
  _CLASS_GOBJECT(Bus, GstBus, GST_BUS, Object, GstObject)

protected:
  _CTOR_DEFAULT()

public:
  /** For example,
   * bool on_bus_watch(const Glib::RefPtr<Bus>& bus, const
   * Glib::RefPtr<Message>& message);
   */
  typedef sigc::slot< bool, const Glib::RefPtr<Bus>&, const Glib::RefPtr<Message>& > SlotWatch;

  static Glib::RefPtr<Bus> create();
  _WRAP_METHOD(bool post(const Glib::RefPtr<Message>& message), gst_bus_post)
  _WRAP_METHOD(bool have_pending() const, gst_bus_have_pending)

  _WRAP_METHOD(Glib::RefPtr<Message> peek(), gst_bus_peek)
  _WRAP_METHOD(Glib::RefPtr<const Message> peek() const, gst_bus_peek)

  _WRAP_METHOD(Glib::RefPtr<Message> pop(), gst_bus_pop)
  _WRAP_METHOD(Glib::RefPtr<Message> pop(MessageType message_type), gst_bus_pop_filtered)
  _WRAP_METHOD(Glib::RefPtr<Message> pop(ClockTime timeout), gst_bus_timed_pop)
  _WRAP_METHOD(Glib::RefPtr<Message> pop(ClockTime timeout, MessageType message_type), gst_bus_timed_pop_filtered)

  _WRAP_METHOD(void set_flushing(bool flushing = true), gst_bus_set_flushing)

  guint add_watch(const SlotWatch& slot, int priority = Glib::PRIORITY_DEFAULT);
  bool remove_watch(guint watch_id);
  _IGNORE(gst_bus_add_watch, gst_bus_add_watch_full)

  _WRAP_METHOD(void disable_sync_message_emission(), gst_bus_disable_sync_message_emission)
  _WRAP_METHOD(void enable_sync_message_emission(), gst_bus_enable_sync_message_emission)

  _WRAP_METHOD(void add_signal_watch(int priority = Glib::PRIORITY_DEFAULT), gst_bus_add_signal_watch_full)
  _WRAP_METHOD(void remove_signal_watch(), gst_bus_remove_signal_watch)
  _WRAP_METHOD(Glib::RefPtr<Message> poll(MessageType message_type, ClockTimeDiff timeout), gst_bus_poll)
  _IGNORE(gst_bus_add_signal_watch)

#m4 _CONVERSION(`GstMessage*',`const Glib::RefPtr<Message>&', `Gst::Message::wrap($3, true)')
  _WRAP_SIGNAL(void message(const Glib::RefPtr<Message>& message), "message")
  _WRAP_SIGNAL(void sync_message(const Glib::RefPtr<Message>& message), "sync-message")
};

} //namespace Gst
