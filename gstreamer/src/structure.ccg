#include <gst/gstvalue.h> //Must be included before gststructure.h
#include <gst/gststructure.h>

namespace Gst
{

static gboolean
Structure_ForEach_gstreamermm_callback(GQuark field_id, const GValue *value, gpointer data)
{
  Structure::ForeachSlot& slot = *static_cast<Structure::ForeachSlot*>(data);
  return slot(field_id, value);
}

static gboolean
Structure_Map_gstreamermm_callback(GQuark field_id, GValue *value, gpointer data)
{
  Structure::MapSlot& slot = *static_cast<Structure::MapSlot*>(data);
  return slot(field_id, value);
}

Structure::Structure(const Glib::ustring& name)
{
  gobject_ = gst_structure_empty_new(name.c_str());
}

void
Structure::get_field(const Glib::ustring& name, Glib::ValueBase& value) const
{
  value.init(gst_structure_get_value(gobj(), name.c_str()));
}

bool
Structure::get_boolean(const Glib::ustring& name, Glib::ValueBase& value) const
{
  bool result = gst_structure_has_field_typed(gobj(), name.c_str(), G_TYPE_BOOLEAN);

  if (result)
    value.init(gst_structure_get_value(gobj(), name.c_str()));

  return result;
}

bool
Structure::get_int(const Glib::ustring& name, Glib::ValueBase& value) const
{
  bool result = gst_structure_has_field_typed(gobj(), name.c_str(), G_TYPE_INT);

  if (result)
    value.init(gst_structure_get_value(gobj(), name.c_str()));

  return result;
}

bool
Structure::get_uint(const Glib::ustring& name, Glib::ValueBase& value) const
{
  bool result = gst_structure_has_field_typed(gobj(), name.c_str(), G_TYPE_UINT);

  if (result)
    value.init(gst_structure_get_value(gobj(), name.c_str()));

  return result;
}

bool
Structure::get_fourcc(const Glib::ustring& name, Glib::ValueBase& value) const
{
  bool result = gst_structure_has_field_typed(gobj(), name.c_str(), G_TYPE_UINT);

  if (result)
    value.init(gst_structure_get_value(gobj(), name.c_str()));

  return result;
}


bool
Structure::get_double(const Glib::ustring& name, Glib::ValueBase& value) const
{
  bool result = gst_structure_has_field_typed(gobj(), name.c_str(), G_TYPE_DOUBLE);

  if (result)
    value.init(gst_structure_get_value(gobj(), name.c_str()));

  return result;
}

bool
Structure::get_string(const Glib::ustring& name, Glib::ValueBase& value) const
{
  bool result = gst_structure_has_field_typed(gobj(), name.c_str(), G_TYPE_STRING);

  if (result)
    value.init(gst_structure_get_value(gobj(), name.c_str()));

  return result;
}

bool
Structure::get_date (const Glib::ustring& name, Glib::Date& value) const
{
  GDate *date = 0;
  const bool has = gst_structure_get_date(gobj(), name.c_str(), &date);
  value.set_julian(g_date_get_julian(date));
  return has;
}


bool
Structure::get_clock_time(const Glib::ustring& name, Glib::ValueBase& value) const
{
  bool result = gst_structure_has_field_typed(gobj(), name.c_str(), G_TYPE_UINT64);

  if (result)
    value.init(gst_structure_get_value(gobj(), name.c_str()));

  return result;
}


bool
Structure::get_enum(const Glib::ustring& name, GType enum_type, Glib::ValueBase& value) const
{
  bool result = gst_structure_has_field_typed(gobj(), name.c_str(), enum_type);

  if (result)
    value.init(gst_structure_get_value(gobj(), name.c_str()));

  return result;
}


bool
Structure::get_fraction(const Glib::ustring& name, int& value_numerator, int& value_denominator) const
{
  return gst_structure_get_fraction(gobj(), name.c_str(), &value_numerator, &value_denominator);
}

bool
Structure::foreach(const ForeachSlot& slot)
{
  ForeachSlot slot_copy(slot);
  gst_structure_foreach(gobj(), &Structure_ForEach_gstreamermm_callback, &slot_copy);
}

bool
Structure::map_in_place(const MapSlot& slot)
{
  MapSlot slot_copy(slot);
  gst_structure_map_in_place(gobj(), &Structure_Map_gstreamermm_callback, &slot_copy);
}

Structure
Structure::create_from_string(const Glib::ustring& the_string)
{
  return Structure(gst_structure_from_string(the_string.c_str(), NULL)); 
}

} //namespace Gst
