/* gstreamermm - a C++ wrapper for gstreamer
 *
 * Copyright 2008-2009 The gstreamermm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <cstring>
#include <gst/audio/audio-enumtypes.h>
_PINCLUDE(gstreamermm/private/object_p.h)

// This constant is obtained from the "silence_sample" member in the
// GstRingBufferSpec structure definition.
#define GSTREAMERMM_RING_BUFFER_SPEC_SILENCE_SAMPLE 32

namespace
{

extern "C"
{

static void RingBuffer_Fill_gstreamermm_callback(GstRingBuffer*, guint8* data, guint len,
                                                 gpointer user_data)
{
  Gst::RingBuffer::SlotFill& slot_fill = *static_cast<Gst::RingBuffer::SlotFill*>(user_data);

#ifdef GLIBMM_EXCEPTIONS_ENABLED
  try
#endif
  {
    Glib::ArrayHandle<guint8> cpp_data(data, len, Glib::OWNERSHIP_NONE);
    slot_fill(cpp_data, len);
  }
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  catch (...)
  {
    Glib::exception_handlers_invoke();
  }
#endif
}

} // extern "C"

} // anonymous namespace

namespace Gst
{

RingBufferSpec::RingBufferSpec()
: m_spec(g_new(GstRingBufferSpec, 1)),
  take_ownership(true)
{}

RingBufferSpec::RingBufferSpec(const Glib::RefPtr<Gst::Caps>& caps,
  Gst::BufferFormatType type, Gst::BufferFormat format, bool sign,
  bool bigend, int width, int depth, int rate, int channels,
  guint64 latency_time, guint64 buffer_time, int segsize, int segtotal,
  int seglatency)
: m_spec(g_new(GstRingBufferSpec, 1)),
  take_ownership(true)
  
{
  GstRingBufferSpec* spec = gobj();

  spec->caps = Glib::unwrap(caps);

  // Keep a copy of the caps (it will be unreferenced in the destructor).
  if (caps)
    caps->reference();

  spec->type = static_cast<GstBufferFormatType>(type);
  spec->format = static_cast<GstBufferFormat>(format);
  spec->sign = static_cast<int>(sign);
  spec->bigend = static_cast<int>(bigend);
  spec->width = width;
  spec->depth = depth;
  spec->rate = rate;
  spec->channels = channels;
  spec->latency_time = latency_time;
  spec->buffer_time = buffer_time;
  spec->segsize = segsize;
  spec->segtotal = segtotal;
  spec->seglatency = seglatency;
}


RingBufferSpec::RingBufferSpec(GstRingBufferSpec& castitem, bool take_ownership)
: m_spec(&castitem),
  take_ownership(take_ownership)
{
  // Keep a copy of the caps (it will be unreferenced in the destructor).
  if(castitem.caps)
      gst_caps_ref(castitem.caps);
}

RingBufferSpec::RingBufferSpec(const RingBufferSpec& other)
: m_spec(g_new(GstRingBufferSpec, 1)),
  take_ownership(true)
{
  m_spec->caps = other.m_spec->caps;

  // Keep a copy of the caps (it will be unreferenced in the destructor).
  if(m_spec->caps)
    gst_caps_ref(m_spec->caps);

  m_spec->type = other.m_spec->type;
  m_spec->format = other.m_spec->format;
  m_spec->sign = other.m_spec->sign;
  m_spec->bigend = other.m_spec->bigend;
  m_spec->width = other.m_spec->width;
  m_spec->depth = other.m_spec->depth;
  m_spec->rate = other.m_spec->rate;
  m_spec->channels = other.m_spec->channels;
  m_spec->latency_time = other.m_spec->latency_time;
  m_spec->buffer_time = other.m_spec->buffer_time;
  m_spec->segsize = other.m_spec->segsize;
  m_spec->segtotal = other.m_spec->segtotal;
  m_spec->bytes_per_sample = other.m_spec->bytes_per_sample;
  m_spec->seglatency = other.m_spec->seglatency;

  std::copy(other.m_spec->silence_sample, other.m_spec->silence_sample + GSTREAMERMM_RING_BUFFER_SPEC_SILENCE_SAMPLE, m_spec->silence_sample);
}

RingBufferSpec& RingBufferSpec::operator=(const RingBufferSpec& other)
{
  RingBufferSpec temp(other);
  swap(temp);
  return *this;
}

RingBufferSpec::~RingBufferSpec()
{
  // Unref existing reference to caps.
  if(m_spec->caps)
    gst_caps_unref(m_spec->caps);

  // Release the underlying m_spec if it is owned.
  if(take_ownership)
    g_free(m_spec);
}

void RingBufferSpec::swap(RingBufferSpec& other)
{
  GstRingBufferSpec* spec_temp = m_spec;
  m_spec = other.m_spec;
  other.m_spec = spec_temp;

  const bool take_temp = take_ownership;
  take_ownership = other.take_ownership;
  other.take_ownership = take_temp;
}

GstRingBufferSpec* RingBufferSpec::gobj()
{
  return m_spec;
}

const GstRingBufferSpec* RingBufferSpec::gobj() const
{
  return m_spec;
}

Glib::RefPtr<Gst::Caps> RingBufferSpec::qet_caps()
{
  return Glib::wrap(m_spec->caps);
}

void RingBufferSpec::set_caps(const Glib::RefPtr<Gst::Caps>& caps)
{
  // Unrefence possible previous caps.
  if(m_spec->caps)
    gst_caps_unref(m_spec->caps);

  m_spec->caps = Glib::unwrap(caps);

  // Keep a copy of the new caps (it will be unreferenced in the destructor).
  if(m_spec->caps)
    gst_caps_ref(m_spec->caps);
}

Gst::BufferFormatType RingBufferSpec::qet_type()
{
  return static_cast<Gst::BufferFormatType>(m_spec->type);
}

void RingBufferSpec::set_type(Gst::BufferFormatType type)
{
  m_spec->type = static_cast<GstBufferFormatType>(type);
}

Gst::BufferFormat RingBufferSpec::qet_format()
{
  return static_cast<Gst::BufferFormat>(m_spec->format);
}

void RingBufferSpec::set_format(Gst::BufferFormat format)
{
  m_spec->format = static_cast<GstBufferFormat>(format);
}

bool RingBufferSpec::qet_sign()
{
  return static_cast<bool>(m_spec->sign);
}

void RingBufferSpec::set_sign(bool sign)
{
  m_spec->sign = static_cast<gboolean>(sign);
}

bool RingBufferSpec::qet_bigend()
{
  return static_cast<bool>(m_spec->bigend);
}

void RingBufferSpec::set_bigend(bool bigend)
{
  m_spec->sign = static_cast<gboolean>(bigend);
}

int RingBufferSpec::qet_width()
{
  return m_spec->width;
}

void RingBufferSpec::set_width(int width)
{
  m_spec->width = width;
}

int RingBufferSpec::qet_depth()
{
  return m_spec->depth;
}

void RingBufferSpec::set_depth(int depth)
{
  m_spec->depth = depth;
}

int RingBufferSpec::qet_rate()
{
  return m_spec->rate;
}

void RingBufferSpec::set_rate(int rate)
{
  m_spec->rate = rate;
}

int RingBufferSpec::qet_channels()
{
  return m_spec->channels;
}

void RingBufferSpec::set_channels(int channels)
{
  m_spec->channels = channels;
}

guint64 RingBufferSpec::qet_latency_time()
{
  return m_spec->latency_time;
}

void RingBufferSpec::set_latency_time(guint64 latency_time)
{
  m_spec->latency_time = latency_time;
}

guint64 RingBufferSpec::qet_buffer_time()
{
  return m_spec->buffer_time;
}

void RingBufferSpec::set_buffer_time(guint64 buffer_time)
{
  m_spec->buffer_time = buffer_time;
}

int RingBufferSpec::qet_segsize()
{
  return m_spec->segsize;
}

void RingBufferSpec::set_segsize(int segsize)
{
  m_spec->segsize = segsize;
}

int RingBufferSpec::qet_segtotal()
{
  return m_spec->segtotal;
}

void RingBufferSpec::set_segtotal(int segtotal)
{
  m_spec->segtotal = segtotal;
}

int RingBufferSpec::qet_seglatency()
{
  return m_spec->seglatency;
}

void RingBufferSpec::set_seglatency(int seglatency)
{
  m_spec->seglatency = seglatency;
}

int RingBufferSpec::qet_bytes_per_sample()
{
  return m_spec->bytes_per_sample;
}

void RingBufferSpec::set_bytes_per_sample(int bytes_per_sample)
{
  m_spec->bytes_per_sample = bytes_per_sample;
}

Glib::ArrayHandle<guint8> RingBufferSpec::get_silence_sample()
{
  return Glib::ArrayHandle<guint8>(m_spec->silence_sample,
    GSTREAMERMM_RING_BUFFER_SPEC_SILENCE_SAMPLE, Glib::OWNERSHIP_NONE);
}

void RingBufferSpec::set_silence_sample(const Glib::ArrayHandle<guint8>& silence_sample)
{
  std::copy(silence_sample.data(),
    silence_sample.data() + GSTREAMERMM_RING_BUFFER_SPEC_SILENCE_SAMPLE,
    m_spec->silence_sample);
}

void RingBuffer::set_fill_slot(const SlotFill& slot)
{
  // The slot is dynamically allocated because according to the
  // gst_ring_buffer_set_callback() docs, the slot may be called several times.
  // A copy is hence created to avoid losing the slot.  The copy is kept in an
  // auto_ptr<> so that is released upon the ring buffer's destruction.
  m_slot.reset(new SlotFill(slot));

  gst_ring_buffer_set_callback(gobj(), &RingBuffer_Fill_gstreamermm_callback,
    m_slot.get());
}

bool RingBuffer::prepare_read(int& segment, std::vector<guint8>& readptr,
  int& len)
{
  guint8* c_readptr = 0;

  const bool result = static_cast<bool>(gst_ring_buffer_prepare_read(gobj(), &segment, &c_readptr, &len));
  readptr.assign(c_readptr, c_readptr + len);

  if (c_readptr)
    g_free(c_readptr);

  return result;
}

#ifdef GLIBMM_VFUNCS_ENABLED
gboolean RingBuffer_Class::acquire_vfunc_callback(GstRingBuffer* self, GstRingBufferSpec* spec)
{
  Glib::ObjectBase *const obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    CppObjectType *const obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
      #endif //GLIBMM_EXCEPTIONS_ENABLED
        Gst::RingBufferSpec cpp_spec(*spec);

        // Call the virtual member method, which derived classes might override.
        return static_cast<int>(obj->acquire_vfunc(cpp_spec));

      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
      #endif //GLIBMM_EXCEPTIONS_ENABLED
    }
  }
  
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->acquire)
    return (*base->acquire)(self, spec);


  typedef gboolean RType;
  return RType();
}
bool Gst::RingBuffer::acquire_vfunc(Gst::RingBufferSpec& spec) 
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->acquire)
    return static_cast<bool>((*base->acquire)(gobj(), spec.gobj()));

  typedef bool RType;
  return RType();
}
guint RingBuffer_Class::commit_vfunc_callback(GstRingBuffer* self, guint64* sample, guchar* data, gint in_samples, gint out_samples, gint* accum)
{
  Glib::ObjectBase *const obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    CppObjectType *const obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
      #endif //GLIBMM_EXCEPTIONS_ENABLED
        // This formula is obtained from the definition of the data_end
        // variable in the default_commit() function of the C API
        // gstringbuffer.c file.
        size_t data_length = (self->spec.bytes_per_sample * in_samples);

        // Declare the ArrayHandle for the C++ vfunc.
        Glib::ArrayHandle<guchar> cpp_data(data, data_length, Glib::OWNERSHIP_NONE);
        // Call the virtual member method, which derived classes might override.
        return obj->commit_vfunc(*(sample), cpp_data, in_samples, out_samples,
          *(accum));
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
      #endif //GLIBMM_EXCEPTIONS_ENABLED
    }
  }
  
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
  );

  // Call the original underlying C function:
  if(base && base->commit)
    return (*base->commit)(self, sample, data, in_samples, out_samples, accum);


  typedef guint RType;
  return RType();
}
guint Gst::RingBuffer::commit_vfunc(guint64& sample, const Glib::ArrayHandle<guchar>& data, int in_samples, int out_samples, int& accum) 
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->commit)
    return (*base->commit)(gobj(),&sample,const_cast<guchar*>(data.data()),in_samples,out_samples,&accum);

  typedef guint RType;
  return RType();
}
#endif //GLIBMM_VFUNCS_ENABLED

} // namespace Gst
