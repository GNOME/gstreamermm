// -*- Mode: C++; indent-tabs-mode: nil; c-basic-offset: 2 -*-

/* gstreamermm - a C++ wrapper for gstreamer
 *
 * Copyright 2008 The gstreamermm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gstreamermm/element.h>
#include <gstreamermm/childproxy.h>
#include <gstreamermm/pad.h>

_DEFS(gstreamermm,gst)
_PINCLUDE(glibmm/private/object_p.h)
_PINCLUDE(gstreamermm/private/element_p.h)

namespace Gst
{

class Pad;

//TODO: Correct statements about iterators in class docs below:

/** Bin â€” Base class and element that can contain other elements.
 * Bin is an element that can contain other Element, allowing them to be
 * managed as a group. Pads from the child elements can be ghosted to the bin,
 * see GstGhostPad. This makes the bin look like any other elements and enables
 * creation of higher-level abstraction elements.
 *
 * A new Bin is created with create(). Use a Pipeline instead if you want to
 * create a toplevel bin because a normal bin doesn't have a bus or handle
 * clock distribution of its own.
 *
 * After the bin has been created you will typically add elements to it with
 * add(). You can remove elements with remove().
 *
 * An element can be retrieved from a bin with get_element(), using the
 * elements name. get_element_recurse_up() is mainly used for internal purposes
 * and will query the parent bins when the element is not found in the current
 * bin.
 *
 * An iterator of elements in a bin can be retrieved with iterate_elements().
 * Various other iterators exist to retrieve the elements in a bin.
 *
 * The element-added signal is fired whenever a new element is added to the
 * bin. Likewise the element-removed signal is fired whenever an element is
 * removed from the bin.
 *
 * Notes:
 *
 * A Bin internally intercepts every Message posted by its children and
 * implements the following default behaviour for each of them:
 *
 * MESSAGE_EOS - This message is only posted by sinks in the PLAYING state. If
 * all sinks posted the EOS message, this bin will post and EOS message
 * upwards.
 *
 * MESSAGE_SEGMENT_START - just collected and never forwarded upwards. The
 * messages are used to decide when all elements have completed playback of
 * their segment.
 *
 * MESSAGE_SEGMENT_DONE - Is posted by Bin when all elements that posted a
 * SEGMENT_START have posted a SEGMENT_DONE.
 *
 * MESSAGE_DURATION - Is posted by an element that detected a change in the
 * stream duration. The default bin behaviour is to clear any cached duration
 * values so that the next duration query will perform a full duration
 * recalculation. The duration change is posted to the application so that it
 * can refetch the new duration with a duration query.
 *
 * MESSAGE_CLOCK_LOST - This message is posted by an element when it can no
 * longer provide a clock. The default bin behaviour is to check if the lost
 * clock was the one provided by the bin. If so and the bin is currently in the
 * PLAYING state, the message is forwarded to the bin parent. This message is
 * also generated when a clock provider is removed from the bin. If this
 * message is received by the application, it should PAUSE the pipeline and set
 * it back to PLAYING to force a new clock distribution.
 *
 * MESSAGE_CLOCK_PROVIDE - This message is generated when an element can
 * provide a clock. This mostly happens when a new clock provider is added to
 * the bin. The default behaviour of the bin is to mark the currently selected
 * clock as dirty, which will perform a clock recalculation the next time the
 * bin is asked to provide a clock. This message is never sent tot the
 * application but is forwarded to the parent of the bin.
 *
 * OTHERS - posted upwards.

 * A Bin implements the following default behaviour for answering to a Query:
 *
 * QUERY_DURATION - If the query has been asked before with the same format and
 * the bin is a toplevel bin (ie. has no parent), use the cached previous
 * value. If no previous value was cached, the query is sent to all sink
 * elements in the bin and the MAXIMUM of all values is returned. If the bin is
 * a toplevel bin the value is cached. If no sinks are available in the bin,
 * the query fails.
 *
 * QUERY_POSITION - The query is sent to all sink elements in the bin and the
 * MAXIMUM of all values is returned. If no sinks are available in the bin, the
 * query fails.
 *
 * OTHERS - the query is forwarded to all sink elements, the result of the
 * first sink that answers the query successfully is returned. If no sink is in
 * the bin, the query fails.
 *
 * A Bin will by default forward any event sent to it to all sink elements. If
 * all the sinks return TRUE, the bin will also return TRUE, else FALSE is
 * returned. If no sinks are in the bin, the event handler will return TRUE.
 *
 * Last reviewed on 2006-04-28 (0.10.6)
 */
class Bin
: public Element,
  public ChildProxy
{
  _CLASS_GOBJECT(Bin, GstBin, GST_BIN, Element, GstElement)
  _IMPLEMENTS_INTERFACE(ChildProxy)

protected:
  _WRAP_CTOR(Bin(const Glib::ustring& name), gst_bin_new)

public:
  _WRAP_CREATE(const Glib::ustring& name)

  Glib::RefPtr<Bin> add(const Glib::RefPtr<Element>& element);
  Glib::RefPtr<Bin> remove(const Glib::RefPtr<Element>& element);

  _WRAP_METHOD(Glib::RefPtr<Element> get_element(const Glib::ustring& name), gst_bin_get_by_name)
  _WRAP_METHOD(Glib::RefPtr<Element> get_element_recurse_up(const Glib::ustring& name), gst_bin_get_by_name_recurse_up)
  _WRAP_METHOD(Glib::RefPtr<Element> get_element(GType interface), gst_bin_get_by_interface)
  _WRAP_METHOD(Glib::RefPtr<Pad> find_unconnected_pad(PadDirection dir), gst_bin_find_unconnected_pad)

  _IGNORE(gst_bin_add, gst_bin_remove, gst_bin_add_many, gst_bin_remove_many)

#m4 _CONVERSION(`GstElement*',`const Glib::RefPtr<Element>&', `Glib::wrap($3, true)')
  _WRAP_SIGNAL(void element_added(const Glib::RefPtr<Element>& element), "element-added")
  _WRAP_SIGNAL(void element_removed(const Glib::RefPtr<Element>& element), "element-removed")

  _WRAP_PROPERTY("async-handling", bool)
};

} //namespace Gst
