// -*- Mode: C++; indent-tabs-mode: nil; c-basic-offset: 2 -*-

/* gstreamermm - a C++ wrapper for gstreamer
 *
 * Copyright 2008 The gstreamermm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gst/gstcaps.h>
#include <gstreamermm/structure.h>

_DEFS(gstreamermm,gst)

namespace Gst
{

struct Structure;

/** Caps â€” Structure describing sets of media formats.
 * Caps (capabilities) are lighweight refcounted objects describing media
 * types. They are composed of an array of Structure.
 *
 * Caps are exposed on PadTemplate to describe all possible types a given pad
 * can handle. They are also stored in the Registry along with a description of
 * the Element.
 *
 * Caps are exposed on the element pads using the Gst::Pad::get_caps() method.
 * This method describes the possible types that the pad can handle or produce
 * at runtime.
 *
 * Caps are also attached to buffers to describe to content of the data pointed
 * to by the buffer with Gst::Buffer:set_caps(). Caps attached to a Buffer
 * allow for format negotiation upstream and downstream.
 *
 * A Caps can be constructed with the following code fragment:
 *
 * TODO: Insert C++ translated code fragment from C API docs
 */
class Caps 
{
  _CLASS_OPAQUE_REFCOUNTED(Caps, GstCaps, gst_caps_new_empty, gst_caps_ref, gst_caps_unref)
  _IGNORE(gst_caps_ref, gst_caps_unref)

public:
  /** Creates a new Caps that indicates that it is compatible with any media
   * format.
   *
   * @return the new Caps
   */
  static Glib::RefPtr<Caps> create_any();

  /** Creates a new Caps that contains one Structure. Caller is responsible for
   * unreffing the returned caps.
   *
   * @param media_type the media type of the structure
   * @return the new GstCaps
   */
  static Glib::RefPtr<Caps> create_simple(const Glib::ustring& media_type);

  /** Creates a new GstCaps and adds the first Structure given. The structure
   * is not copied; the returned Caps owns the structure.
   *
   * @param first_struct the first structure to add
   * @return Returns the new GstCaps
   */
  static Glib::RefPtr<Caps> create(Structure& first_struct);

  _WRAP_METHOD(Glib::RefPtr<Caps> copy() const, gst_caps_copy)
  _WRAP_METHOD(Glib::RefPtr<Caps> copy_nth(guint nth), gst_caps_copy_nth)
  _WRAP_METHOD(void append(const Glib::RefPtr<Caps>& caps), gst_caps_append)
  _WRAP_METHOD(void merge(const Glib::RefPtr<Caps>& caps), gst_caps_merge)

  /** Appends structure to caps. The structure is not copied; caps becomes the
   * owner of structure.
   *
   * @param structure the Structure to append
   */
  void append_structure(Structure& structure);

  /** Appends structure to caps if its not already expressed by caps. The
   * structure is not copied; caps becomes the owner of structure.
   *
   * @param structure the Structure to merge
   */
  void merge_structure(Structure& structure);

  /** Finds the structure in caps that has the index idx, and returns it.
   *
   * @param index the index of the structure
   * @return the Structure corresponding to index
   */
  const Structure* get_structure(guint idx) const;

  _WRAP_METHOD(void remove_structure(guint idx), gst_caps_remove_structure)
  _WRAP_METHOD(guint get_size() const, gst_caps_get_size)

  /** Sets a fields in a simple Caps. A simple Caps is one that only has one
   * structure.
   *
   * @param field field to set
   * @param value the value which the field should be set to
   */
  void set_simple(const Glib::ustring& name, const Glib::ValueBase& value);

  _WRAP_METHOD(void set_simple_valist(char* field, const va_list& varargs), gst_caps_set_simple_valist)

  _WRAP_METHOD(bool is_any() const, gst_caps_is_any)
  _WRAP_METHOD(bool is_empty() const, gst_caps_is_empty)
  _WRAP_METHOD(bool is_fixed() const, gst_caps_is_fixed)
  _WRAP_METHOD(bool is_equal(const Glib::RefPtr<Caps>& other_caps) const, gst_caps_is_equal)
  _WRAP_METHOD(bool is_equal_fixed(const Glib::RefPtr<Caps>& other_caps) const, gst_caps_is_equal_fixed)
  _WRAP_METHOD(bool is_always_compatible(const Glib::RefPtr<Caps>& other_caps) const, gst_caps_is_always_compatible)
  _WRAP_METHOD(bool is_subset(const Glib::RefPtr<Caps>& superset_caps) const, gst_caps_is_subset)
  _WRAP_METHOD(Glib::RefPtr<Caps> get_intersect(const Glib::RefPtr<Caps>& other_caps) const, gst_caps_intersect)
  _WRAP_METHOD(Glib::RefPtr<Caps> get_union(const Glib::RefPtr<Caps>& other_caps) const, gst_caps_union)
  _WRAP_METHOD(Glib::RefPtr<Caps> normalize(), gst_caps_normalize)
  _WRAP_METHOD(bool simplify(), gst_caps_do_simplify)
  _WRAP_METHOD(xmlNodePtr save(const xmlNodePtr& parent) const, gst_caps_save_thyself)
  _WRAP_METHOD(static Glib::RefPtr<Caps> load(xmlNodePtr parent), gst_caps_load_thyself)

  _WRAP_METHOD(Glib::ustring to_string() const, gst_caps_to_string)

  _WRAP_METHOD(static Glib::RefPtr<Caps> from_string(const Glib::ustring& string), gst_caps_from_string)

  _WRAP_METHOD(Glib::RefPtr<Caps> subtract(const Glib::RefPtr<const Caps>& subtrahend_caps), gst_caps_subtract)
  _WRAP_METHOD(Glib::RefPtr<Caps> make_writable(), gst_caps_make_writable)
  _WRAP_METHOD(void truncate(), gst_caps_truncate)
  
  _IGNORE(gst_caps_copy, gst_caps_set_simple, gst_caps_make_writable)
};

} //namespace Gst
