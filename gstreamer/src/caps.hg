// -*- Mode: C++; indent-tabs-mode: nil; c-basic-offset: 2 -*-

/* gstreamermm - a C++ wrapper for gstreamer
 *
 * Copyright 2008 The gstreamermm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gst/gstcaps.h>
#include <gstreamermm/structure.h>

_DEFS(gstreamermm,gst)

namespace Gst
{

struct Structure;

/** Gst::Caps (capabilities) are lightweight objects describing media
 * formats. They are composed of an array of Gst::Structure.
 *
 * Gst::Caps are exposed on Gst::PadTemplate to describe all possible types a
 * given pad can handle. They are also stored in the Gst::Registry along with a
 * description of the Gst::Element.
 *
 * Gst::Caps are exposed on the element pads using the Gst::Pad::get_caps()
 * method.  This method describes the possible types that the pad can handle or
 * produce at runtime.
 *
 * Gst::Caps are also attached to buffers to describe to content of the data
 * pointed to by the buffer with Gst::Buffer::set_caps(). Gst::Caps attached to
 * a Gst::Buffer allow for format negotiation upstream and downstream.
 *
 * A Gst::Caps can be constructed with the following code fragment:
 *
 * TODO: Insert C++ translated code fragment from C API docs
 */
class Caps 
{
  _CLASS_OPAQUE_REFCOUNTED(Caps, GstCaps, gst_caps_new_empty, gst_caps_ref, gst_caps_unref)
  _IGNORE(gst_caps_ref, gst_caps_unref)

public:

  /** Creates a new Gst::Caps that indicates that it is compatible with any
   * media format.
   *
   * @return the new Gst::Caps
   */
  static Glib::RefPtr<Caps> create_any();

  /** Creates a new Gst::Caps that contains one Gst::Structure.
   *
   * @param media_type the media type of the structure
   * @return the new Gst::Caps
   */
  static Glib::RefPtr<Caps> create_simple(const Glib::ustring& media_type);

  /** Creates a new Gst::Caps and adds the given Gst::Structure.
   * Use append_structure() to add additional structures.
   *
   * @param first_struct the first structure to add
   * @return Returns the new Gst::Caps
   */
  static Glib::RefPtr<Caps> create(const Structure& first_struct);

  _WRAP_METHOD(static Glib::RefPtr<Caps> create_from_string(const Glib::ustring& string), gst_caps_from_string)


  _WRAP_METHOD(Glib::RefPtr<Caps> copy() const, gst_caps_copy)
  _WRAP_METHOD(Glib::RefPtr<Caps> copy_nth(guint nth) const, gst_caps_copy_nth)
  _WRAP_METHOD(void append(const Glib::RefPtr<Caps>& caps), gst_caps_append)
  _WRAP_METHOD(void merge(const Glib::RefPtr<Caps>& caps), gst_caps_merge)

  //TODO: This talk of ownership is strange. Say what it really means somewhere. murrayc.
  /** Appends a structure to caps. The structure is not copied. This Caps becomes the
   * owner of @a structure.
   *
   * @param structure the Gst::Structure to append
   */
  void append_structure(const Structure& structure);

  /** Appends a structure to caps if its not already expressed by caps. The
   * structure is not copied. This Caps becomes the owner of @a structure.
   *
   * @param structure the Gst::Structure to merge
   */
  void merge_structure(const Structure& structure);

  /** Finds the structure in caps that has the index @a idx, and returns it.
   *
   * @param index the index of the structure
   * @return the Gst::Structure corresponding to index
   */
  Structure get_structure(guint idx) const;

  _WRAP_METHOD(void remove_structure(guint idx), gst_caps_remove_structure)
  _WRAP_METHOD(guint size() const, gst_caps_get_size)

  //TODO: Avoid forcing applications to use Glib::Value<>. See what TreeModel does.

  /** Sets fields in a simple Gst::Caps. A simple Gst::Caps is one that only
   * has one structure.
   *
   * @param field field to set
   * @param value the value which the field should be set to
   */
  void set_simple(const Glib::ustring& name, const Glib::ValueBase& value);
  _IGNORE(gst_caps_set_simple)

  //This does not seem useful: _WRAP_METHOD(void set_simple_valist(char* field, const va_list& varargs), gst_caps_set_simple_valist)
  _IGNORE(gst_caps_set_simple_valist)

  _WRAP_METHOD(bool is_any() const, gst_caps_is_any)
  _WRAP_METHOD(bool empty() const, gst_caps_is_empty)
  _WRAP_METHOD(bool is_fixed() const, gst_caps_is_fixed)
  _WRAP_METHOD(bool equals(const Glib::RefPtr<Caps>& other_caps) const, gst_caps_is_equal)
  _WRAP_METHOD(bool equals_fixed(const Glib::RefPtr<Caps>& other_caps) const, gst_caps_is_equal_fixed)
  _WRAP_METHOD(bool is_always_compatible(const Glib::RefPtr<Caps>& other_caps) const, gst_caps_is_always_compatible)
  _WRAP_METHOD(bool is_subset(const Glib::RefPtr<Caps>& superset_caps) const, gst_caps_is_subset)

  //TODO: Rename as create_*()?
  //This is const (returns a non const) because it always creates a new instance:
  _WRAP_METHOD(Glib::RefPtr<Caps> get_intersect(const Glib::RefPtr<Caps>& other_caps) const, gst_caps_intersect)

  //This is const (returns a non const) because it always creates a new instance:
  _WRAP_METHOD(Glib::RefPtr<Caps> get_union(const Glib::RefPtr<Caps>& other_caps) const, gst_caps_union)

  //This is const (returns a non const) because it always creates a new instance:
  _WRAP_METHOD(Glib::RefPtr<Caps> normalize() const, gst_caps_normalize)

  _WRAP_METHOD(bool simplify(), gst_caps_do_simplify)

  //TODO: Add overloads (and dependency) for libxml++?
  _WRAP_METHOD(xmlNodePtr save(const xmlNodePtr& parent) const, gst_caps_save_thyself)
  _WRAP_METHOD(static Glib::RefPtr<Caps> load(xmlNodePtr parent), gst_caps_load_thyself)

  _WRAP_METHOD(Glib::ustring to_string() const, gst_caps_to_string)

 //TODO: Rename as create_*()?
  _WRAP_METHOD(Glib::RefPtr<Caps> subtract(const Glib::RefPtr<const Caps>& subtrahend_caps), gst_caps_subtract)
  _WRAP_METHOD(Glib::RefPtr<Caps> make_writable(), gst_caps_make_writable)
  _WRAP_METHOD(void truncate(), gst_caps_truncate)
  
  _IGNORE(gst_caps_copy, gst_caps_set_simple, gst_caps_make_writable, gst_caps_append_structure, gst_caps_merge_structure, gst_caps_get_structure)
};

} //namespace Gst
