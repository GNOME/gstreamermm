// -*- Mode: C++; indent-tabs-mode: nil; c-basic-offset: 2 -*-

/* gstreamermm - a C++ wrapper for gstreamer
 *
 * Copyright 2008 The gstreamermm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gst/gstelement.h>
#include <gstreamermm/object.h>
#include <gstreamermm/clock.h>
#include <gstreamermm/enums.h>
#include <gstreamermm/event.h>
#include <gstreamermm/message.h>
#include <gstreamermm/query.h>
#include <stdexcept> //Because link() throws std::runtime_error

_DEFS(gstreamermm,gst)

namespace Gst
{

class Bus;
class Caps;
class Clock;
class ElementFactory;
class Event;
class Index;
class Interface;
class Message;
class Pad;
class PadTemplate;
class Query;
class TagList;

//Gst::Iterator<> forward declaration.
template <class CppType>
class Iterator;

_WRAP_ENUM(ElementFlags, GstElementFlags)

//TODO: Fix gmmproc so that definition in gst_enums.defs does not cause errors
//and this can be wrapped with _WRAP_ENUM.
enum StateChange
{
  STATE_CHANGE_NULL_TO_READY = GST_STATE_CHANGE_NULL_TO_READY,
  STATE_CHANGE_READY_TO_PAUSED = GST_STATE_CHANGE_READY_TO_PAUSED,
  STATE_CHANGE_PAUSED_TO_PLAYING = GST_STATE_CHANGE_PAUSED_TO_PLAYING,
  STATE_CHANGE_PLAYING_TO_PAUSED = GST_STATE_CHANGE_PLAYING_TO_PAUSED,
  STATE_CHANGE_PAUSED_TO_READY = GST_STATE_CHANGE_PAUSED_TO_READY,
  STATE_CHANGE_READY_TO_NULL = GST_STATE_CHANGE_READY_TO_NULL 
};

_WRAP_ENUM(StateChangeReturn, GstStateChangeReturn)

namespace Enums
{

/**  Gets a string representing the given state.
 *
 * @param state A Gst::State to get the name of.
 * @return A Glib::ustring with the name of the state.
 */
Glib::ustring get_name(State state);

/** Gets a string representing the given state change result.
 *
 * @param state_ret A Gst::StateChangeReturn to get the name of.
 * @return A Glib::ustring with the name of the state change result.
 */
Glib::ustring get_name(StateChangeReturn state_ret);

} //namespace Enums

/** Gst::Element â€” Abstract base class for all pipeline elements.
 * Gst::Element is the abstract base class needed to construct an element that
 * can be used in a GStreamer pipeline. Please refer to the plugin writers
 * guide for more information on creating Gst::Element subclasses.
 *
 * The name of a Gst::Element can be get with get_name() and set with
 * set_name().
 *
 * All elements have pads (of the type Gst::Pad). These pads link to pads on
 * other elements. Gst::Buffer flow between these linked pads. An Element has a
 * GList of Gst::Pad structures for all their input (or sink) and output (or
 * source) pads.  Core and plug-in writers can add and remove pads with
 * add_pad() and remove_pad().
 *
 * A pad of an element can be retrieved by name with get_request_pad() or
 * get_static_pad(). An iterator of all pads can be retrieved with
 * iterate_pads().
 *
 * Gst::Elements can be linked through their pads. Use the link() function to
 * link elements. Use link_filtered() to link two elements constrained by a
 * specified set of Gst::Caps. For finer control, use link_pads() and
 * link_pads_filtered() to specify the pads to link on each element by name.
 *
 * Each element has a state (see State). You can get and set the state of an
 * element with get_state() and set_state(). To get a string representation of
 * a State, use Gst::Enums::get_name().
 *
 * You can get and set a Clock on an element using get_clock() and set_clock().
 * Some elements can provide a clock for the pipeline if provides_clock()
 * returns true. With the provide_clock() method one can retrieve the clock
 * provided by such an element. Not all elements require a clock to operate
 * correctly. If requires_clock() returns true, a clock should be set on the
 * element with set_clock().
 *
 * Note that clock slection and distribution is normally handled by the
 * toplevel Gst::Pipeline so the clock functions are only to be used in very
 * specific situations.
 *
 * Last reviewed on 2006-03-12 (0.10.5)
 */
class Element : public Gst::Object
{
  _CLASS_GOBJECT(Element, GstElement, GST_ELEMENT, Gst::Object, GstObject)

protected:
  //Needed for ElementInterfaced derived class
  _CTOR_DEFAULT

public:
  /** Links this source element to the @dest element.
   * The link must be from source to destination - the other direction will not be tried. 
   * The function looks for existing pads that aren't linked yet. It will request new pads
   * if necessary. Such pads need to be released manually when unlinking. 
   * If multiple links are possible, only one is established.
   *
   * Make sure you have added your elements to a bin or pipeline with Gst::Bin::add() before 
   * trying to link them.
   *
   * @throws std::runtime_error If the elements could not be linked.
   */
  Glib::RefPtr<Element> link(const Glib::RefPtr<Element>& dest);
  _IGNORE(gst_element_link, gst_element_link_many)

  _WRAP_METHOD(bool add_pad(const Glib::RefPtr<Pad>& pad), gst_element_add_pad)
  _WRAP_METHOD(void create_all_pads(), gst_element_create_all_pads)

  //TODO: Can this be const?
  Glib::RefPtr<Pad> create_compatible_pad(const Glib::RefPtr<Pad>& pad, const Glib::RefPtr<Caps>& caps);
  _IGNORE(gst_element_get_compatible_pad)

  //TODO: Can this be const?
  Glib::RefPtr<PadTemplate> get_compatible_pad_template(const Glib::RefPtr<PadTemplate>& padtemplate);
  _IGNORE(gst_element_get_compatible_pad_template)

  //TODO: The documentation says "The pad should be released with gst_element_release_request_pad().", which is odd. murrayc
  _WRAP_METHOD(Glib::RefPtr<Pad> get_request_pad(const Glib::ustring& name), gst_element_get_request_pad)
  _WRAP_METHOD(Glib::RefPtr<Pad> get_static_pad(const Glib::ustring& name), gst_element_get_static_pad)
  _IGNORE(gst_element_get_pad)

  _WRAP_METHOD(void no_more_pads(), gst_element_no_more_pads)
  _WRAP_METHOD(void release_request_pad(const Glib::RefPtr<Pad>& pad), gst_element_release_request_pad)
  _WRAP_METHOD(bool remove_pad(const Glib::RefPtr<Pad>& pad), gst_element_remove_pad)
  _WRAP_METHOD(Iterator<Pad> iterate_pads(), gst_element_iterate_pads)
  _WRAP_METHOD(Iterator<Pad> iterate_sink_pads(), gst_element_iterate_sink_pads)
  _WRAP_METHOD(Iterator<Pad> iterate_src_pads(), gst_element_iterate_src_pads)
  _WRAP_METHOD(void unlink(const Glib::RefPtr<Element>& other_element), gst_element_unlink)
  _IGNORE(gst_element_unlink_many)

  //TODO: Make this like link()?
  _WRAP_METHOD(bool link_pads(const Glib::ustring& padname, const Glib::RefPtr<Element>& other_element, const Glib::ustring& others_padname), gst_element_link_pads)

  _WRAP_METHOD(void unlink_pads(const Glib::ustring& padname, const Glib::RefPtr<Element>& other_element, const Glib::ustring& other_padname), gst_element_unlink_pads)

  //TODO: Make this like link()?
  _WRAP_METHOD(bool link_pads_filtered(const Glib::ustring& padname, const Glib::RefPtr<Element>& other_element, const Glib::ustring& others_padname, const Glib::RefPtr<Caps>& filter), gst_element_link_pads_filtered)

  //TODO: Make this like link()?
  _WRAP_METHOD(bool link_filtered(const Glib::RefPtr<Element>& other_element, const Glib::RefPtr<Caps>& filter), gst_element_link_filtered)

  _WRAP_METHOD(void set_base_time(ClockTime time), gst_element_set_base_time)
  _WRAP_METHOD(ClockTime get_base_time() const, gst_element_get_base_time)
  _WRAP_METHOD(void set_bus(const Glib::RefPtr<Bus>& bus), gst_element_set_bus)
  _WRAP_METHOD(Glib::RefPtr<Bus> get_bus(), gst_element_get_bus)
  _WRAP_METHOD(Glib::RefPtr<const Bus> get_bus() const, gst_element_get_bus, constversion)
  _WRAP_METHOD(void set_index(const Glib::RefPtr<Index>& index), gst_element_set_index)

  //Note: gst_element_get_index provides a reference.
  _WRAP_METHOD(Glib::RefPtr<Index> get_index(), gst_element_get_index)
  _WRAP_METHOD(Glib::RefPtr<const Index > get_index() const, gst_element_get_index, constversion)

  _WRAP_METHOD(Glib::RefPtr<ElementFactory> get_factory(), gst_element_get_factory, refresult)
  _WRAP_METHOD(Glib::RefPtr<const ElementFactory> get_factory() const, gst_element_get_factory, refresult, constversion)

  _WRAP_METHOD(bool is_indexable() const, gst_element_is_indexable)
  _WRAP_METHOD(bool requires_clock() const, gst_element_requires_clock)
  _WRAP_METHOD(bool set_clock(const Glib::RefPtr<Clock>& clock), gst_element_set_clock)
  _WRAP_METHOD(Glib::RefPtr<Clock> get_clock(), gst_element_get_clock)
  _WRAP_METHOD(Glib::RefPtr<const Clock> get_clock() const, gst_element_get_clock, constversion)
  _WRAP_METHOD(bool provides_clock() const, gst_element_provides_clock)
  _WRAP_METHOD(Glib::RefPtr<Clock> provide_clock(), gst_element_provide_clock)
  _WRAP_METHOD(Glib::RefPtr<const Clock> provide_clock() const, gst_element_provide_clock, constversion)
  _WRAP_METHOD(StateChangeReturn set_state(State state), gst_element_set_state)
  _WRAP_METHOD(StateChangeReturn get_state(State& state, State& pending, ClockTime timeout) const, gst_element_get_state)
  _WRAP_METHOD(bool set_locked_state(gboolean locked_state), gst_element_set_locked_state)
  _WRAP_METHOD(bool is_locked_state() const, gst_element_is_locked_state)
  _WRAP_METHOD(void abort_state(), gst_element_abort_state)
  _WRAP_METHOD(StateChangeReturn continue_state(StateChangeReturn prestate_value), gst_element_continue_state)
  _WRAP_METHOD(void lost_state(), gst_element_lost_state)
  _WRAP_METHOD(bool sync_state_with_parent(), gst_element_sync_state_with_parent)
  _WRAP_METHOD(StateChangeReturn change_state(StateChange transition), gst_element_change_state)
  _WRAP_METHOD(void found_tags(const TagList& list), gst_element_found_tags)
  _WRAP_METHOD(void found_tags_for_pad(const Glib::RefPtr<Pad>& pad, const TagList& list), gst_element_found_tags_for_pad)

  //TODO: Change the parameter order?
  _WRAP_METHOD(void post_message(MessageType message_type, const Glib::QueryQuark& domain, int code, const Glib::ustring& message, const Glib::ustring& debug, const Glib::ustring& filename, const Glib::ustring& function_name, int line_number), gst_element_message_full)
  _WRAP_METHOD(bool post_message(const Glib::RefPtr<Message>& message), gst_element_post_message)

#m4 _CONVERSION(`const GstQueryType*',`Glib::ArrayHandle<QueryType>',`Glib::ArrayHandle<QueryType>((QueryType*)($3), Glib::OWNERSHIP_SHALLOW)')
  _WRAP_METHOD(Glib::ArrayHandle<QueryType> get_query_types() const, gst_element_get_query_types)

  _WRAP_METHOD(bool query(const Glib::RefPtr<Query>& query), gst_element_query)
  _WRAP_METHOD(bool query_convert(Format src_format, gint64 src_value, Format& dst_format, gint64& dst_value) const, gst_element_query_convert)
  _WRAP_METHOD(bool query_position(Format& format, gint64& position) const, gst_element_query_position)

  /** Queries an element for the stream position.
   *
   * @param format A pointer to the Gst::Format asked for. On return will
   * contain the Gst::Format used.
   * @return true if the query could be performed.
   */
  bool query_position(Format& format) const;

  _WRAP_METHOD(bool query_duration(Format& format, gint64& duration) const, gst_element_query_duration)

  /** Queries an element for the total stream duration.
   *
   * @param format A pointer to the Gst::Format asked for. On return contains
   * the Gst::Format used.
   * @return true if the query could be performed.
   */
  bool query_duration(Format& format) const;

  _WRAP_METHOD(bool seek(Format format, SeekFlags flags, gint64 position), gst_element_seek_simple)
  _WRAP_METHOD(bool seek(double rate, Format format, SeekFlags flags, SeekType current_type, gint64 current_position, SeekType stop_type, gint64 stop_position), gst_element_seek)

  /** Sends an event to an element. If the element doesn't implement an event
   * handler, the event will be pushed on a random linked sink pad for upstream
   * events or a random linked source pad for downstream events.
   *
   * This function takes owership of the provided event.
   *
   * @param event The Gst::Event to send to the element.
   * @return true if the event was handled. MT safe. 
   */
  bool send_event(const Glib::RefPtr<Event>& event);
  _IGNORE(gst_element_send_event)

  _WRAP_METHOD(bool implements_interface(GType iface_type), gst_element_implements_interface)

  /** This signals that the element will not generate more dynamic pads.
   */
  _WRAP_SIGNAL(void no_more_pads(), "no-more-pads")

#m4 _CONVERSION(`GstPad*',`const Glib::RefPtr<Pad>&',`Glib::wrap($3, true)')

  /** signals that a new Gst::Pad has been added to the element.
   */
  _WRAP_SIGNAL(void pad_added(const Glib::RefPtr<Pad>& new_pad), "pad-added")

  /** signals that a Gst::Pad has been removed from the element
   */
  _WRAP_SIGNAL(void pad_removed(const Glib::RefPtr<Pad>& old_pad), "pad-removed")

  /** Called when a new pad is requested.
   */
  _WRAP_VFUNC(Glib::RefPtr<Pad> request_new_pad(const Glib::RefPtr<PadTemplate>& templ, const Glib::ustring& name), "request_new_pad")

  /** Called when a request pad is to be released.
   */
  _WRAP_VFUNC(void release_pad(const Glib::RefPtr<Pad>& pad), "release_pad")

  /** Get the state of the element.
   */
  _WRAP_VFUNC(StateChangeReturn get_state(State& state, State& pending, ClockTime timeout), "get_state")

  /** Set a new state on the element.
   */
  _WRAP_VFUNC(StateChangeReturn set_state(State state), "set_state")

  /** Called by set_state to perform an incremental state change.
   */
  _WRAP_VFUNC(StateChangeReturn change_state(StateChange transition), "change_state")

  /** Set a Gst::Bus on the element.
   */
  _WRAP_VFUNC(void set_bus(const Glib::RefPtr<Bus>& bus), "set_bus")

  /** Gets the Gst::Clock provided by the element.
   */
  _WRAP_VFUNC(Glib::RefPtr<Clock> provide_clock(), "provide_clock")

  /** Set the Gst::Clock on the element.
   */
  _WRAP_VFUNC(bool set_clock(const Glib::RefPtr<Clock>& clock), "set_clock")

  /** Get a Gst::Index on the element.
   */
  _WRAP_VFUNC(Glib::RefPtr<Index> get_index(), "get_index")

  /** Set the Gst::Index of an element.
   */
  _WRAP_VFUNC(void set_index(const Glib::RefPtr<Index>& index), "set_index")

  /** Send a Gst::Event to the element.
   */
  _WRAP_VFUNC(bool send_event(const Glib::RefPtr<Event>& event), "send_event")

  //TODO: This vfunc can't be wrapped without getting a compile error in the
  //generated code.  The compile error comes about because the code assumes
  //that Glib::ArrayHandle<> has a default constructor but it does not.  The
  //way the code is generated will have to be tweaked.
  //
//#m4 _CONVERSION(`Glib::ArrayHandle<QueryType>',`const GstQueryType*',`(GstQueryType*)(($3).data())')
  // /** Get the supported GstQueryType of this element.
  //  */
  // _WRAP_VFUNC(Glib::ArrayHandle<QueryType> get_query_types(), "get_query_types")

  /** Perform a Gst::Query on the element.
   */
  _WRAP_VFUNC(bool query(const Glib::RefPtr<Query>& query), "query")
};

/** Templated class used for casting Gst::Element to interfaces that its
 * underlying gobject implements.
 * Gst::ElementInterfaced is a templated class which, in conjunction with
 * Gst::Interface::cast(), is used to cast a Gst::Element obtained by
 * Gst::ElementFactory::create_element() into underlying GStreamer interfaces
 * that the element may implement.  A 'filesrc' element, for example,
 * implements the Gst::URIHandler interface (which is not reflected in a
 * Gst::Element obtained from a Gst::ElementFactory).  To use the
 * Gst::URIHandler methods with a 'filesrc' element obtained from a
 * Gst::ElementFactory, one would do the following:
 * @code
 * ...
 * Glib::RefPtr<Gst::Element> element =
 * Gst::ElementFactory::create_element("filesrc", "source");
 *
 * Glib::RefPtr< Gst::ElementInterfaced<Gst::URIHandler> > handler =
 *   Gst::Interface::cast<Gst::URIHandler>(element);
 *
 * if (handler)
 * {
 *   std::cout << "element '" << element->get_name() <<
 *     "' implements URIHandler interface." << std::endl;
 *
 *   // Use uri handler interface methods:
 *
 *   handler->set_uri("file:///tmp/media.file");
 *
 *   std::cout << handler->get_name() << " uri = '" << handler->get_uri() <<
 *     "'." << std::endl;
 * }
 * @endcode
 */
template <class T_Interface>
class ElementInterfaced
: public Element,
  public T_Interface
{
public:
  // Make calls involving underlying gobject unambiguous (specifically, gobj()
  // is ambiguous when called from an ElementInterfaced<..> class
  GstElement* gobj();
  const GstElement* gobj() const;
  GstElement* gobj_copy();

  ~ElementInterfaced();

protected:
  ElementInterfaced(const ElementInterfaced&);
  ElementInterfaced& operator=(const ElementInterfaced&);

protected:
  ElementInterfaced(GstElement* castitem);

private:
  friend class Gst::Interface;
};

#ifndef DOXYGEN_SHOULD_SKIP_THIS

void ElementInterfaced_WeakNotify_gstreamermm_callback(void* data, GObject* where_the_object_was);

template <class T_Interface>
ElementInterfaced<T_Interface>::ElementInterfaced(GstElement* castitem)
{
  gobject_ = (GObject*)castitem;
  if (gobject_) {
    gst_object_ref(Element::gobj());
    g_object_weak_ref(gobject_,
      &ElementInterfaced_WeakNotify_gstreamermm_callback, this);
  }
}

template <class T_Interface>
GstElement* ElementInterfaced<T_Interface>::gobj()
{
  return Element::gobj();
}

template <class T_Interface>
const GstElement* ElementInterfaced<T_Interface>::gobj() const
{
  return Element::gobj();
}

template <class T_Interface>
GstElement* ElementInterfaced<T_Interface>::gobj_copy()
{
  return Element::gobj_copy();
}

template <class T_Interface>
ElementInterfaced<T_Interface>::~ElementInterfaced()
{
  // Set the gobject_ to NULL so that when this is deleted, the gobject doesn't
  // go with it and other elements "wrapping" the gobject are not affected
  gobject_ = 0;
}

#endif /* DOXYGEN_SHOULD_SKIP_THIS */

} // namespace Gst
