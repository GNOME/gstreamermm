// -*- Mode: C++; indent-tabs-mode: nil; c-basic-offset: 2 -*-

/* gstreamermm - a C++ wrapper for gstreamer
 *
 * Copyright 2008 The gstreamermm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gstreamermm/object.h>
#include <gstreamermm/clock.h>
#include <gstreamermm/enums.h>

_DEFS(gstreamermm,gst)
_PINCLUDE(gstreamermm/private/object_p.h)

namespace Gst
{

class Bus;
class Caps;
class Clock;
class ElementFactory;
class Event;
class Index;
class Message;
class Pad;
class PadTemplate;
class Query;

/** Element â€” Abstract base class for all pipeline elements.
 * Element is the abstract base class needed to construct an element that can
 * be used in a GStreamer pipeline. Please refer to the plugin writers guide
 * for more information on creating Element subclasses.
 *
 * The name of a Element can be get with get_name() and set with set_name().
 *
 * All elements have pads (of the type Pad). These pads link to pads on other
 * elements. Buffer flow between these linked pads. A Element has a GList of
 * Pad structures for all their input (or sink) and output (or source) pads.
 * Core and plug-in writers can add and remove pads with add_pad() and
 * remove_pad().
 *
 * A pad of an element can be retrieved by name with get_pad(). An iterator of
 * all pads can be retrieved with gst_element_iterate_pads().
 *
 * Elements can be linked through their pads. Use the link() function to link
 * elements. Use link_filtered() to link two elements constrained by a
 * specified set of Caps. For finer control, use link_pads() and
 * link_pads_filtered() to specify the pads to link on each element by name.
 *
 * Each element has a state (see State). You can get and set the state of an
 * element with get_state() and set_state(). To get a string representation of
 * a State, use state_get_name().
 *
 * You can get and set a Clock on an element using get_clock() and set_clock().
 * Some elements can provide a clock for the pipeline if provides_clock()
 * returns TRUE. With the provide_clock() method one can retrieve the clock
 * provided by such an element. Not all elements require a clock to operate
 * correctly. If requires_clock() returns TRUE, a clock should be set on the
 * element with set_clock().
 *
 * Note that clock slection and distribution is normally handled by the
 * toplevel Pipeline so the clock functions are only to be used in very
 * specific situations.
 *
 * Last reviewed on 2006-03-12 (0.10.5)
 */
class Element : public Gst::Object
{
  _CLASS_GOBJECT(Element, GstElement, GST_ELEMENT, Gst::Object, GstObject)

public:
  Glib::RefPtr<Element> link(const Glib::RefPtr<Element>& other_element);
  _WRAP_METHOD(bool add_pad(const Glib::RefPtr<Pad>& pad), gst_element_add_pad)
  _WRAP_METHOD(Glib::RefPtr<Pad> get_pad(const Glib::ustring& name), gst_element_get_pad)
  _WRAP_METHOD(void create_all_pads(), gst_element_create_all_pads)

  //TODO: Why does this throw an exception? murrayc
  Glib::RefPtr<Pad> get_compatible_pad(const Glib::RefPtr<Pad>& pad, const Glib::RefPtr<Caps>& caps);
  Glib::RefPtr<PadTemplate> get_compatible_pad_template(const Glib::RefPtr<PadTemplate>& padtemplate);

  _WRAP_METHOD(Glib::RefPtr<Pad> get_request_pad(const Glib::ustring& name), gst_element_get_request_pad)
  _WRAP_METHOD(Glib::RefPtr<Pad> get_static_pad(const Glib::ustring& name), gst_element_get_static_pad)
  _WRAP_METHOD(void no_more_pads(), gst_element_no_more_pads)
  _WRAP_METHOD(void release_request_pad(const Glib::RefPtr<Pad>& pad), gst_element_release_request_pad)
  _WRAP_METHOD(bool remove_pad(const Glib::RefPtr<Pad>& pad), gst_element_remove_pad)
 
  _WRAP_METHOD(void unlink(const Glib::RefPtr<Element>& other_element), gst_element_unlink)

  _WRAP_METHOD(bool link_pads(const Glib::ustring& padname, const Glib::RefPtr<Element>& other_element, const Glib::ustring& others_padname), gst_element_link_pads)

  _WRAP_METHOD(void unlink_pads(const Glib::ustring& padname, const Glib::RefPtr<Element>& other_element, const Glib::ustring& other_padname), gst_element_unlink_pads)

  //TODO: Use ustring?:
  _WRAP_METHOD(bool link_pads_filtered(const char* padname, const Glib::RefPtr<Element>& other_element, const char* others_padname, const Glib::RefPtr<Caps>& filter), gst_element_link_pads_filtered)

  _WRAP_METHOD(bool link_filtered(const Glib::RefPtr<Element>& other_element, const Glib::RefPtr<Caps>& filter), gst_element_link_filtered)
  _WRAP_METHOD(void set_base_time(ClockTime time), gst_element_set_base_time)
  _WRAP_METHOD(ClockTime get_base_time() const, gst_element_get_base_time)
  _WRAP_METHOD(void set_bus(const Glib::RefPtr<Bus>& bus), gst_element_set_bus)
  _WRAP_METHOD(Glib::RefPtr<Bus> get_bus(), gst_element_get_bus)
  _WRAP_METHOD(Glib::RefPtr<const Bus> get_bus() const, gst_element_get_bus, constversion)
  _WRAP_METHOD(void set_index(const Glib::RefPtr<Index>& index), gst_element_set_index)

  //Note: gst_element_get_index provides a reference.
  _WRAP_METHOD(Glib::RefPtr<Index> get_index(), gst_element_get_index)
  _WRAP_METHOD(Glib::RefPtr<Index const> get_index() const, gst_element_get_index, constversion)


  _WRAP_METHOD(Glib::RefPtr<ElementFactory> get_factory(), gst_element_get_factory)
  _WRAP_METHOD(bool is_indexable() const, gst_element_is_indexable)
  _WRAP_METHOD(bool requires_clock() const, gst_element_requires_clock)
  _WRAP_METHOD(bool set_clock(const Glib::RefPtr<Clock>& clock), gst_element_set_clock)
  _WRAP_METHOD(Glib::RefPtr<Clock> get_clock(), gst_element_get_clock)
  _WRAP_METHOD(Glib::RefPtr<const Clock> get_clock() const, gst_element_get_clock, constversion)
  _WRAP_METHOD(bool provides_clock() const, gst_element_provides_clock)
  _WRAP_METHOD(Glib::RefPtr<Clock> provide_clock(), gst_element_provide_clock)
  _WRAP_METHOD(Glib::RefPtr<const Clock> provide_clock() const, gst_element_provide_clock, constversion)
  _WRAP_METHOD(StateChangeReturn set_state(State state), gst_element_set_state)
  _WRAP_METHOD(StateChangeReturn get_state(State& state, State& pending, ClockTime timeout) const, gst_element_get_state)
  _WRAP_METHOD(bool set_locked_state(gboolean locked_state), gst_element_set_locked_state)
  _WRAP_METHOD(bool is_locked_state() const, gst_element_is_locked_state)
  _WRAP_METHOD(void abort_state(), gst_element_abort_state)
  _WRAP_METHOD(StateChangeReturn continue_state(StateChangeReturn prestate_value), gst_element_continue_state)
  _WRAP_METHOD(void lost_state(), gst_element_lost_state)
  _WRAP_METHOD(bool sync_state_with_parent(), gst_element_sync_state_with_parent)
  _WRAP_METHOD(StateChangeReturn change_state(StateChange transition), gst_element_change_state)

  //TODO: Change the parameter order?
  _WRAP_METHOD(void post_message(MessageType message_type, GQuark domain, int code, const Glib::ustring& message, const Glib::ustring& debug, const Glib::ustring& filename, const Glib::ustring& function_name, int line_number), gst_element_message_full)
  _WRAP_METHOD(bool post_message(const Glib::RefPtr<Message>& message), gst_element_post_message)

  //TODO: Use ArrayHandle?
  _WRAP_METHOD(const QueryType* get_query_types() const, gst_element_get_query_types)

  _WRAP_METHOD(bool query(const Glib::RefPtr<Query>& query), gst_element_query)
  _WRAP_METHOD(bool query_convert(Format src_format, gint64 src_value, Format& dst_format, gint64& dst_value) const, gst_element_query_convert)
  _WRAP_METHOD(bool query_position(Format& format, gint64& position) const, gst_element_query_position)
  _WRAP_METHOD(bool query_duration(Format& format, gint64& duration) const, gst_element_query_duration)

  bool query_position(Format& format) const;
  bool query_duration(Format& format) const;

  _WRAP_METHOD(bool seek(Format format, SeekFlags flags, gint64 position), gst_element_seek_simple)
  _WRAP_METHOD(bool seek(double rate, Format format, SeekFlags flags, SeekType current_type, gint64 current_position, SeekType stop_type, gint64 stop_position), gst_element_seek)

  bool send_event(const Glib::RefPtr<Event>& event);

  _WRAP_METHOD(bool implements_interface(GType iface_type), gst_element_implements_interface)

  _IGNORE(gst_element_link, gst_element_unlink_many, gst_element_get_compatible_pad, gst_element_get_compatible_pad_template, gst_element_link_many, gst_element_send_event)

  _WRAP_SIGNAL(void no_more_pads(), "no-more-pads")

#m4 _CONVERSION(`GstPad*',`const Glib::RefPtr<Pad>&',`Glib::wrap($3, true)')
  _WRAP_SIGNAL(void pad_added(const Glib::RefPtr<Pad>& new_pad), "pad-added")
  _WRAP_SIGNAL(void pad_removed(const Glib::RefPtr<Pad>& old_pad), "pad-removed")
};

} // namespace Gst

