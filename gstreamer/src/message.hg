// -*- Mode: C++; indent-tabs-mode: nil; c-basic-offset: 2 -*-

/* gstreamermm - a C++ wrapper for gstreamer
 *
 * Copyright 2008 The gstreamermm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gstreamermm/miniobject.h>
#include <gstreamermm/structure.h>
#include <gstreamermm/wrap.h>

_DEFS(gstreamermm,gst)
_PINCLUDE(gstreamermm/private/miniobject_p.h)

namespace Gst
{

class Message : public Gst::MiniObject
{
protected:
 _CLASS_GSTMINIOBJECT(Message, GstMessage, GST_MESSAGE, Gst::MiniObject, GstMiniObject)
 _IGNORE(gst_message_ref, gst_message_unref)
public:
  /** Get the structure of a message.
   * @return The Structure of the message (unmodifiable)
   */
  const Structure* get_structure();

public:
  /** Wrap a GstMessage* in a C++ instance, creating an instance of a
   *  derived Gst::Message.  Gst::wrap() would just create a Gst::Message
   *  (rather than a derived one) because the derived Gst::Message classes
   *  do not correspond to GType types in the GStreamer API.
   */
  static Glib::RefPtr<Message> wrap(GstMessage* message, bool take_copy=false);

  _MEMBER_GET(message_type, type, MessageType, GstMessageType)
  _MEMBER_GET(timestamp, timestamp, ClockTime, guint64)
  _MEMBER_GET_GOBJECT(source, src, Gst::Object, GstObject*)

protected: 
  Structure structure_;
};

class MessageApplication : public Message
{
public:
  explicit MessageApplication(GstMessage *message);

  static Glib::RefPtr<Message> create(const Glib::RefPtr<Object>& src, Structure& structure);
};

class MessageClockProvide : public Message
{
public:
  explicit MessageClockProvide(GstMessage *message);

  static Glib::RefPtr<Message> create(const Glib::RefPtr<Object>& src, const Glib::RefPtr<Clock>& clock, bool ready);
  void parse(Glib::RefPtr<Clock>& clock, bool& ready);
};

class MessageClockLost : public Message
{
public:
  explicit MessageClockLost(GstMessage* castitem);

  static Glib::RefPtr<Message> create(const Glib::RefPtr<Object>& src, const Glib::RefPtr<Clock>& clock);
  void parse(Glib::RefPtr<Clock>& clock);
};

class MessageCustom : public Message
{
public:
  explicit MessageCustom(GstMessage* castitem);

  static Glib::RefPtr<Message> create(MessageType type, const Glib::RefPtr<Object>& src, Structure& structure);
};

class MessageElement : public Message
{
public:
  explicit MessageElement(GstMessage* castitem);

  static Glib::RefPtr<Message> create(const Glib::RefPtr<Object>& src, Structure& structure);
};

class MessageEos : public Message
{
public:
  explicit MessageEos(GstMessage* castitem);

  static Glib::RefPtr<Message> create(const Glib::RefPtr<Object>& src);
};

class MessageError : public Message
{
public:
  explicit MessageError(GstMessage* castitem);

  static Glib::RefPtr<Message> create(const Glib::RefPtr<Object>& src, Glib::Error& error, const std::string& debug);
  void parse(Glib::Error& error, std::string& debug);
  void parse(Glib::Error& error);
};

class MessageInfo : public Message
{
public:
  explicit MessageInfo(GstMessage* castitem);

  static Glib::RefPtr<Message> create(const Glib::RefPtr<Object>& src, Glib::Error& error, const std::string& debug);
  void parse(Glib::Error& error, std::string& debug);
};

class MessageNewClock: public Message
{
public:
  explicit MessageNewClock(GstMessage* castitem);

  static Glib::RefPtr<Message> create(const Glib::RefPtr<Object>& src, const Glib::RefPtr<Clock>& clock);
  void parse(Glib::RefPtr<Clock>& clock);
};

class MessageSegmentDone : public Message
{
public:
  explicit MessageSegmentDone(GstMessage* castitem);

  static Glib::RefPtr<Message> create(const Glib::RefPtr<Object>& src, Format format, gint64 position);
  void parse(Format& format, gint64& position);
};

class MessageSegmentStart : public Message
{
public:
  explicit MessageSegmentStart(GstMessage* castitem);

  static Glib::RefPtr<Message> create(const Glib::RefPtr<Object>& src, Format format, gint64 position);
  void parse(Format& format, gint64& position);
};

class MessageStateChanged : public Message
{
public:
  explicit MessageStateChanged(GstMessage* castitem);

  static Glib::RefPtr<Message> create(const Glib::RefPtr<Object>& src, State oldstate, State newstate, State pending);
  void parse(State& oldstate, State& newstate, State& pending);
};

//TODO:class MessageTag : public Message
//TODO:{
//TODO:}

class MessageBuffering : public Message
{
public:
  explicit MessageBuffering(GstMessage* castitem);

  static Glib::RefPtr<Message> create(const Glib::RefPtr<Object>& src, int percent);
  void parse(int& percent);
};

class MessageWarning : public Message
{
public:
  explicit MessageWarning(GstMessage* castitem);

  static Glib::RefPtr<Message> create(const Glib::RefPtr<Object>& src, Glib::Error& error, const std::string& debug);
  void parse(Glib::Error& error, std::string& debug);
};

class MessageDuration : public Message
{
public:
  explicit MessageDuration(GstMessage* castitem);

  static Glib::RefPtr<Message> create(const Glib::RefPtr<Object>& src, Format format, gint64 position);
  void parse(Format& format, gint64& position);
};

class MessageStateDirty : public Message
{
public:
  explicit MessageStateDirty(GstMessage* castitem);

  static Glib::RefPtr<Message> create(const Glib::RefPtr<Object>& src);
};

class MessageAsyncStart : public Message
{
public:
  explicit MessageAsyncStart(GstMessage* castitem);

  static Glib::RefPtr<Message> create(const Glib::RefPtr<Object>& src, bool new_base_time);
  void parse(bool& new_base_time);
};

class MessageAsyncDone : public Message
{
public:
  explicit MessageAsyncDone(GstMessage* castitem);

  static Glib::RefPtr<Message> create(const Glib::RefPtr<Object>& src);
};

class MessageLatency : public Message
{
public:
  explicit MessageLatency(GstMessage* castitem);

  static Glib::RefPtr<Message> create(const Glib::RefPtr<Object>& src);
};

} //namespace Gst
