// -*- Mode: C++; indent-tabs-mode: nil; c-basic-offset: 2 -*-

/* gstreamermm - a C++ wrapper for gstreamer
 *
 * Copyright 2008 The gstreamermm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gst/gstevent.h>
#include <gstreamermm/wrap.h>
#include <gstreamermm/format.h>
#include <gstreamermm/clock.h>

_DEFS(gstreamermm,gst)

namespace Gst
{

enum EventType
{
  EVENT_UNKNOWN = GST_EVENT_UNKNOWN,
  /* bidirectional events */
  EVENT_FLUSH_START = GST_EVENT_FLUSH_START,
  EVENT_FLUSH_STOP = GST_EVENT_FLUSH_STOP,
  /* downstream serialized events */
  EVENT_EOS = GST_EVENT_EOS,
  EVENT_NEWSEGMENT = GST_EVENT_NEWSEGMENT,
  EVENT_TAG = GST_EVENT_TAG,
  EVENT_BUFFERSIZE = GST_EVENT_BUFFERSIZE,
  /* upstream events */
  EVENT_QOS = GST_EVENT_QOS,
  EVENT_SEEK = GST_EVENT_SEEK,
  EVENT_NAVIGATION = GST_EVENT_NAVIGATION,
  EVENT_LATENCY = GST_EVENT_LATENCY,

  /* custom events start here */
  EVENT_CUSTOM_UPSTREAM = GST_EVENT_CUSTOM_UPSTREAM,
  EVENT_CUSTOM_DOWNSTREAM = GST_EVENT_CUSTOM_DOWNSTREAM,
  EVENT_CUSTOM_DOWNSTREAM_OOB = GST_EVENT_CUSTOM_DOWNSTREAM_OOB,
  EVENT_CUSTOM_BOTH = GST_EVENT_CUSTOM_BOTH,
  EVENT_CUSTOM_BOTH_OOB = GST_EVENT_CUSTOM_BOTH_OOB
};

_WRAP_ENUM(SeekType, GstSeekType)
_WRAP_ENUM(SeekFlags, GstSeekFlags)
_WRAP_ENUM(EventTypeFlags, GstEventTypeFlags)

class Structure;
class TagList;

namespace Enums
{

/** Get a printable name for the given event type.
 *
 * @param type The event type.
 * @return A reference to the static name of the event.
 */
Glib::ustring get_name(EventType t);

/** Get the unique quark for the given event type.
 *
 * @param type The event type.
 * @return The quark associated with the event type.
 */
Glib::QueryQuark get_quark(EventType t);

} //namespace Enums

/** Gst::Event â€” A structure describing events that are passed up and down a
 * pipeline.
 * The event class provides factory methods to construct and functions query
 * (parse) events.
 *
 * Events are usually created by using the Gst::Event derrived classes'
 * create() methods. To send an event application will usually use
 * Gst::Element::send_event() and elements will use Gst::Pad::send_event() or
 * Gst::Pad::push_event().
 *
 * Events that have been received can be parsed with their respective parse()
 * functions.
 *
 * Events are passed between elements in parallel to the data stream. Some
 * events are serialized with buffers, others are not. Some events only travel
 * downstream, others only upstream. Some events can travel both upstream and
 * downstream.
 *
 * The events are used to signal special conditions in the datastream such as
 * EOS (end of stream) or the start of a new stream-segment. Events are also
 * used to flush the pipeline of any pending data.
 *
 * Most of the event API is used inside plugins. Applications usually only
 * construct and use seek events. To do that Gst::EventSeek::create() is used
 * to create a seek event. It takes the needed parameters to specity seeking
 * time and mode.  The event is then sent to the element like so:
 * @code
 * pipeline->send_event(event);
 * @endcode
 */
class Event : public MiniObject
{
protected:
  _CLASS_GSTMINIOBJECT(Event, GstEvent, GST_EVENT, Gst::MiniObject, GstMiniObject)

public:
  /** Wrap a GstEvent* in a C++ instance, creating an instance of a derived
   * Gst::Event. Gst::wrap() would just create a Gst::Event (rather than a
   * derived one) because the derived Gst::Event classes do not correspond
   * to GType types in the GStreamer API.
   */
  static Glib::RefPtr<Event> wrap(GstEvent* event, bool take_copy=false);

  /** Copy the event using the event specific copy function.
   * @return The Gst::Event copy.
   */
  Glib::RefPtr<Event> copy() const;

  _WRAP_METHOD(const Structure get_structure() const, gst_event_get_structure)
  _WRAP_METHOD(bool has_name(const Glib::ustring& name), gst_event_has_name)

  /** Checks if an event is writable.  If not, a writable copy is made and
   * returned.
   * @return A Gst::Event (possibly the same pointer) that is writable. 
   */
  Glib::RefPtr<Event> create_writable();

  /** Check if an event can travel downstream.
   */
  bool is_downstream() const;

  /** Check if an event is serialized with the data stream.
   */
  bool is_serialized() const;

  /** Check if an event can travel upstream.
   */
  bool is_upstream() const;

  /** Get the Gst::EventType of the event.
   */
  _MEMBER_GET(event_type, type, EventType, GstEventType)

  /** Get the Gst::ClockTime timestamp of the event. This is the time when the
   * event was created.
   */
  _MEMBER_GET(timestamp, timestamp, ClockTime, guint64)

  /** The source Gst::Object that generated this event.
   */
  _MEMBER_GET_GOBJECT(source, src, Gst::Object, GstObject*)
};

//TODO: Modify create methods of derived Event classes to return
//Glib::RefPtr<...> to the derived class and not just Gst::Event. Must deal
//with GstStructure immutability problem (bug #510301) first because casting
//Glib::RefPtrs references the objects which causes problems when GStreamer API
//tries to modify the GstStructures of the objects.

/** A buffer size event.  See create() for more details.
 */
class EventBufferSize : public Event
{
public:
  explicit EventBufferSize(GstEvent* event);

  /** Create a new buffersize event. The event is sent downstream and notifies
   * elements that they should provide a buffer of the specified dimensions.
   *
   * When the async flag is set, a thread boundary is prefered.
   *
   * @param format Buffer format.
   * @param minsize Minimum buffer size.
   * @param maxsize Maximum buffer size.
   * @param async Thread behavior.
   * @return A new Gst::EventBufferSize.
   */
  static Glib::RefPtr<Event> create(Format format, gint64 minsize, gint64 maxsize, bool async);

  /** Get the format, minsize, maxsize and async-flag in the buffersize event.
   *
   * @param format A pointer to store the format in.
   * @param minsize A pointer to store the minsize in.
   * @param maxsize A pointer to store the maxsize in.
   * @param async A pointer to store the async-flag in.
   */
  void parse(Format& format, gint64& minsize, gint64& maxsize, bool& async);
  _IGNORE(gst_event_parse_buffer_size)
};

/** An end of stream event. See create() for more details.
 */
class EventEos : public Event
{
public:
  explicit EventEos(GstEvent* event);

  /** Create a new EOS event. The eos event can only travel downstream
   * synchronized with the buffer flow. Elements that receive the EOS event on
   * a pad can return Gst::FLOW_UNEXPECTED as a Gst::FlowReturn when data after
   * the EOS event arrives.
   *
   * The EOS event will travel down to the sink elements in the pipeline which
   * will then post the Gst::MESSAGE_EOS on the bus after they have finished
   * playing any buffered data.
   *
   * When all sinks have posted an EOS message, an EOS message is forwarded to
   * the application.
   *
   * @return The new EOS event. 
   */
  static Glib::RefPtr<Event> create();
};

/** A flush start event.  See create() for more details.
 */
class EventFlushStart : public Event
{
public:
  explicit EventFlushStart(GstEvent* event);

  /** Allocate a new flush start event. The flush start event can be sent
   * upstream and downstream and travels out-of-bounds with the dataflow.
   *
   * It marks pads as being flushing and will make them return
   * Gst::FLOW_WRONG_STATE when used for data flow with Gst::Pad::push(),
   * Gst::Pad::chain(), Gst::Pad::alloc_buffer(), Gst::Pad::get_range() and
   * Gst::Pad::pull_range(). Any event (except a Gst::EVENT_FLUSH_STOP)
   * received on a flushing pad will return false immediately.
   *
   * Elements should unlock any blocking functions and exit their streaming
   * functions as fast as possible when this event is received.
   *
   * This event is typically generated after a seek to flush out all queued
   * data in the pipeline so that the new media is played as soon as possible.
   *
   * @return A new flush start event.
   */
  static Glib::RefPtr<Event> create();
};

/**  A flush stop event.  See create() for more details.
 */
class EventFlushStop : public Event
{
public:
  explicit EventFlushStop(GstEvent* event);

  /** Allocate a new flush stop event. The flush stop event can be sent
   * upstream and downstream and travels out-of-bounds with the dataflow. It is
   * typically sent after sending a Gst::EventFlushStart event to make the pads
   * accept data again.
   *
   * Elements can process this event synchronized with the dataflow since the
   * preceeding Gst::EventFlushStart event stopped the dataflow.
   *
   * This event is typically generated to complete a seek and to resume
   * dataflow.
   *
   * @return A new flush stop event.
   */
  static Glib::RefPtr<Event> create();
};

/** A latency event.  See create() for more details.
 */
class EventLatency : public Event
{
public:
  explicit EventLatency(GstEvent* event);

  /** Create a new latency event. The event is sent upstream from the sinks and
   * notifies elements that they should add an additional latency to the
   * timestamps before synchronising against the clock.
   *
   * The latency is mostly used in live sinks and is always expressed in the
   * time format.
   *
   * @param latency The new latency value.
   * @return A new Gst::EventLatency.
   *
   * Since 0.10.12 
   */
  static Glib::RefPtr<Event> create(ClockTime latency);

  /** Get the latency in the latency event.
   *
   * @param latency A pointer to store the latency in. 
   */
  void parse(ClockTime& latency);
  _IGNORE(gst_event_parse_latency)
};

/** A Navigation event.  See create() for more details.
 */
class EventNavigation : public Event
{
public:
  explicit EventNavigation(GstEvent* event);

  /** Create a new navigation event from the given description.
   *
   * @param structure Description of the event.
   * @return A new Gst::EventNavigation.
   */
  static Glib::RefPtr<Event> create(Structure& structure);
};

/** A new segment event.  See create() for more details.
 */
class EventNewSegment : public Event
{
public:
  explicit EventNewSegment(GstEvent* event);

  /** Allocate a new newsegment event with the given format/values tripplets
   *
   * The newsegment event marks the range of buffers to be processed. All data
   * not within the segment range is not to be processed. This can be used
   * intelligently by plugins to apply more efficient methods of skipping
   * unneeded data.
   *
   * The position value of the segment is used in conjunction with the start
   * value to convert the buffer timestamps into the stream time. This is
   * usually done in sinks to report the current stream_time. position
   * represents the stream_time of a buffer carrying a timestamp of start.
   * position cannot be -1.
   *
   * start cannot be -1, stop can be -1. If there is a valid stop given, it
   * must be greater or equal the start, including when the indicated playback
   * rate is < 0.
   *
   * The applied_rate value provides information about any rate adjustment that
   * has already been made to the timestamps and content on the buffers of the
   * stream. (rate * applied_rate) should always equal the rate that has been
   * requested for playback. For example, if an element has an input segment
   * with intended playback rate of 2.0 and applied_rate of 1.0, it can adjust
   * incoming timestamps and buffer content by half and output a newsegment
   * event with rate of 1.0 and applied_rate of 2.0
   *
   * After a newsegment event, the buffer stream time is calculated with:
   *
   * position + (TIMESTAMP(buf) - start) * ABS (rate * applied_rate)
   *
   * @param update Is this segment an update to a previous one.
   * @param rate A new rate for playback.
   * @param format The format of the segment values.
   * @param start The start value of the segment.
   * @param stop The stop value of the segment.
   * @param position Stream position.
   * @param applied_rate The rate factor which has already been applied.
   * @return A new newsegment event.
   *
   * Since 0.10.6
   */
  static Glib::RefPtr<Event> create(bool update, double rate, Format format, gint64 strat, gint64 stop, gint64 position, double applied_rate=1.0);

  /** Get the update flag, rate, format, start, stop and position in the
   * newsegment event.
   *
   * @param update A pointer to the update flag of the segment.
   * @param rate A pointer to the rate of the segment.
   * @param format A pointer to the format of the newsegment values.
   * @param start A pointer to store the start value in.
   * @param stop A pointer to store the stop value in.
   * @param position A pointer to store the stream time in.
   */
  void parse(bool& update, double& rate, Format& format, gint64& start, gint64& stop, gint64& position);

  /** Get the update, rate, format, start, stop, position and applied_rate in
   * the newsegment event. See create() for a full description of the
   * newsegment event.
   *
   * @param update A pointer to the update flag of the segment.
   * @param rate A pointer to the rate of the segment.
   * @param format A pointer to the format of the newsegment values.
   * @param start A pointer to store the start value in.
   * @param stop A pointer to store the stop value in.
   * @param position A pointer to store the stream time in.
   * @param applied_rate A pointer to the applied_rate of the segment.
   *
   * Since 0.10.6 
   */
  void parse(bool& update, double& rate, Format& format, gint64& start, gint64& stop, gint64& position, double& applied_rate);
  _IGNORE(gst_event_parse_new_segment, gst_event_parse_new_segment_full)
};

/** A QOS event.  See create() for more details.
 */
class EventQos : public Event
{
public:
  explicit EventQos(GstEvent* event);

  /** Allocate a new qos event with the given values. The QOS event is
   * generated in an element that wants an upstream element to either reduce or
   * increase its rate because of high/low CPU load or other resource usage
   * such as network performance. Typically sinks generate these events for
   * each buffer they receive.
   *
   * proportion indicates the real-time performance of the streaming in the
   * element that generated the QoS event (usually the sink). The value is
   * generally computed based on more long term statistics about the streams
   * timestamps compared to the clock. A value < 1.0 indicates that the
   * upstream element is producing data faster than real-time. A value > 1.0
   * indicates that the upstream element is not producing data fast enough. 1.0
   * is the ideal proportion value. The proportion value can safely be used to
   * lower or increase the quality of the element.
   *
   * diff is the difference against the clock in running time of the last
   * buffer that caused the element to generate the QOS event. A negative value
   * means that the buffer with timestamp arrived in time. A positive value
   * indicates how late the buffer with timestamp was.
   *
   * timestamp is the timestamp of the last buffer that cause the element to
   * generate the QOS event. It is expressed in running time and thus an ever
   * increasing value.
   *
   * The upstream element can use the diff and timestamp values to decide
   * whether to process more buffers. For possitive diff, all buffers with
   * timestamp <= timestamp + diff will certainly arrive late in the sink as
   * well.
   *
   * The application can use general event probes to intercept the QoS event
   * and implement custom application specific QoS handling.
   *
   * @param proportion The proportion of the qos message.
   * @param diff The time difference of the last clock sync.
   * @param timestamp The timestamp of the buffer.
   * @return A new QOS event.
   */
  static Glib::RefPtr<Event> create(double proportion, ClockTimeDiff diff, ClockTime timestamp);

  /** Get the proportion, diff and timestamp in the qos event. See create() for
   * more information about the different QoS values.
   *
   * @param proportion A pointer to store the proportion in.
   * @param diff A pointer to store the diff in.
   * @param timestamp A pointer to store the timestamp in.
   */
  void parse(double& proportion, ClockTimeDiff& diff, ClockTime& timestamp);
  _IGNORE(gst_event_parse_qos)
};

/** A seek event.  See create() for more details.
 */
class EventSeek : public Event
{
public:
  explicit EventSeek(GstEvent* event);

  /** Allocate a new seek event with the given parameters.
   *
   * The seek event configures playback of the pipeline between start to stop
   * at the speed given in rate, also called a playback segment. The start and
   * stop values are expressed in format.
   *
   * A rate of 1.0 means normal playback rate, 2.0 means double speed.
   * Negatives values means backwards playback. A value of 0.0 for the rate is
   * not allowed and should be accomplished instead by PAUSING the pipeline.
   *
   * A pipeline has a default playback segment configured with a start position
   * of 0, a stop position of -1 and a rate of 1.0. The currently configured
   * playback segment can be queried with Gst::QUERY_SEGMENT.
   *
   * start_type and stop_type specify how to adjust the currently configured
   * start and stop fields in segment. Adjustments can be made relative or
   * absolute to the last configured values. A type of Gst::SEEK_TYPE_NONE
   * means that the position should not be updated.
   *
   * When the rate is positive and start has been updated, playback will start
   * from the newly configured start position.
   *
   * For negative rates, playback will start from the newly configured stop
   * position (if any). If the stop position if updated, it must be different
   * from -1 for negative rates.
   *
   * It is not possible to seek relative to the current playback position, to
   * do this, PAUSE the pipeline, query the current playback position with
   * Gst::QUERY_POSITION and update the playback segment current position with
   * a Gst::SEEK_TYPE_SET to the desired position.
   *
   * @param rate The new playback rate.
   * @param format The format of the seek values.
   * @param flags The optional seek flags.
   * @param start_type The type and flags for the new start position.
   * @param start The value of the new start position.
   * @param stop_type The type and flags for the new stop position.
   * @param stop The value of the new stop position.
   * @return A new seek event.
   */
  static Glib::RefPtr<Event> create(double rate, Format format, SeekFlags flags, SeekType start_type, gint64 start, SeekType stop_type, gint64 stop);

  /** Parses a seek event and stores the results in the given result locations.
   *
   * @param rate Result location for the rate.
   * @param format Result location for the stream format.
   * @param flags Result location for the Gst::SeekFlags.
   * @param start_type Result location for the Gst::SeekType of the start
   * position.
   * @param start Result location for the start postion expressed in format.
   * @param stop_type Result location for the Gst::SeekType of the stop
   * position.
   * @param stop Result location for the stop postion expressed in format.
   */
  void parse(double& rate, Format& format, SeekFlags& flags, SeekType& start_type, gint64& start, SeekType& stop_type, gint64& stop);
  _IGNORE(gst_event_parse_seek)
};

/** A tag event.
 */
class EventTag : public Event
{
public:
  explicit EventTag(GstEvent* event);

  /** Generates a metadata tag event from the given taglist.
   * @param taglist Metadata list.
   * @return A new Gst::Event.
   */
  static Glib::RefPtr<Event> create(const TagList& taglist);

  /** Parses a tag event and stores the results in the given taglist location.
   * @return Metadata list.
   */
  TagList parse();
  _IGNORE(gst_event_parse_tag)
};

} //namespace Gst
