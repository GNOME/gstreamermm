/* gstreamermm - a C++ wrapper for gstreamer
 *
 * Copyright 2008 The gstreamermm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gst/gst.h>
#include <gstreamermm/miniobject.h>
#include <gstreamermm/format.h>
#include <gstreamermm/clock.h>


_DEFS(gstreamermm,gst)

namespace Gst
{

  _WRAP_ENUM(SeekType, GstSeekType)
  _WRAP_ENUM(SeekFlags, GstSeekFlags)

_WRAP_ENUM_DOCS_ONLY(EventType, GstEventType)
/* this enum must be wrapped manually since automatic generator (enum.pl) doesn't handle commas properly*/
enum EventType
{
  EVENT_UNKNOWN = GST_EVENT_UNKNOWN,
  /* bidirectional events */
  EVENT_FLUSH_START = GST_EVENT_FLUSH_START,
  EVENT_FLUSH_STOP = GST_EVENT_FLUSH_STOP,
  /* downstream serialized events */
  EVENT_STREAM_START = GST_EVENT_STREAM_START,
  EVENT_CAPS = GST_EVENT_CAPS,
  EVENT_SEGMENT = GST_EVENT_SEGMENT,
  EVENT_TAG = GST_EVENT_TAG,
  EVENT_BUFFERSIZE = GST_EVENT_BUFFERSIZE,
  EVENT_SINK_MESSAGE = GST_EVENT_SINK_MESSAGE,
  EVENT_EOS = GST_EVENT_EOS,
  EVENT_TOC = GST_EVENT_TOC,
  /* non-sticky downstream serialized */
  EVENT_SEGMENT_DONE = GST_EVENT_SEGMENT_DONE,
  EVENT_GAP = GST_EVENT_GAP,
  /* upstream events */
  EVENT_QOS = GST_EVENT_QOS,
  EVENT_SEEK = GST_EVENT_SEEK,
  EVENT_NAVIGATION = GST_EVENT_NAVIGATION,
  EVENT_LATENCY = GST_EVENT_LATENCY,
  EVENT_STEP = GST_EVENT_STEP,
  EVENT_RECONFIGURE = GST_EVENT_RECONFIGURE,
  EVENT_TOC_SELECT = GST_EVENT_TOC_SELECT,
  /* custom events start here */
  EVENT_CUSTOM_UPSTREAM = GST_EVENT_CUSTOM_UPSTREAM,
  EVENT_CUSTOM_DOWNSTREAM = GST_EVENT_CUSTOM_DOWNSTREAM,
  EVENT_CUSTOM_DOWNSTREAM_OOB = GST_EVENT_CUSTOM_DOWNSTREAM_OOB,
  EVENT_CUSTOM_DOWNSTREAM_STICKY = GST_EVENT_CUSTOM_DOWNSTREAM_STICKY,
  EVENT_CUSTOM_BOTH = GST_EVENT_CUSTOM_BOTH,
  EVENT_CUSTOM_BOTH_OOB = GST_EVENT_CUSTOM_BOTH_OOB
};

_WRAP_ENUM(EventTypeFlags, GstEventTypeFlags)
_WRAP_ENUM(QOSType, GstQOSType)

class Message;
class Structure;
class TagList;

namespace Enums
{

/** Gets a printable name for the given event type.
 *
 * @param type The event type.
 * @return A reference to the static name of the event.
 */
Glib::ustring get_name(EventType type);

/** Gets the unique quark for the given event type.
 *
 * @param type The event type.
 * @return The quark associated with the event type.
 */
Glib::QueryQuark get_quark(EventType type);

/** Gets the Gst::EventTypeFlags associated with type.
 * @param type A Gst::EventType.
 * @return A Gst::EventTypeFlags.
 */
EventTypeFlags get_flags(EventType type);

} //namespace Enums

/** A class that represents events that are passed up and down a pipeline.
 * The event class provides factory methods to construct and functions query
 * (parse) events.
 *
 * Events are usually created by using the Gst::Event derrived classes'
 * create() methods. To send an event application will usually use
 * Gst::Element::send_event() and elements will use Gst::Pad::send_event() or
 * Gst::Pad::push_event().
 *
 * Events that have been received can be parsed with their respective parse()
 * functions.
 *
 * Events are passed between elements in parallel to the data stream. Some
 * events are serialized with buffers, others are not. Some events only travel
 * downstream, others only upstream. Some events can travel both upstream and
 * downstream.
 *
 * The events are used to signal special conditions in the datastream such as
 * EOS (end of stream) or the start of a new stream-segment. Events are also
 * used to flush the pipeline of any pending data.
 *
 * Most of the event API is used inside plugins. Applications usually only
 * construct and use seek events. To do that Gst::EventSeek::create() is used
 * to create a seek event. It takes the needed parameters to specity seeking
 * time and mode.  The event is then sent to the element like so:
 * @code
 * pipeline->send_event(event);
 * @endcode
 */
class Event : public MiniObject
{
  _CLASS_OPAQUE_REFCOUNTED(Event, GstEvent, NONE, gst_event_ref, gst_event_unref)
  _IGNORE(gst_event_ref, gst_event_unref)

public:
// A copy is taken so that the original is not freed by the wrapper.
#m4 _CONVERSION(`const GstStructure*',`Gst::Structure',`Glib::wrap(const_cast<GstStructure*>($3), true)')
  _WRAP_METHOD(Gst::Structure get_structure() const, gst_event_get_structure)

  _WRAP_METHOD(bool has_name(const Glib::ustring& name) const, gst_event_has_name)

  _WRAP_METHOD(guint32 get_seqnum() const, gst_event_get_seqnum)
  _WRAP_METHOD(void set_seqnum(guint32 seqnum), gst_event_set_seqnum)

  /** Checks if an event is writable.  If not, a writable copy is made and
   * returned.
   * @return A Gst::Event (possibly the same reference) that is writable. 
   */
  Glib::RefPtr<Gst::Event> create_writable();

  /** Check if an event can travel downstream.
   */
  bool is_downstream() const;

  /** Check if an event is serialized with the data stream.
   */
  bool is_serialized() const;

  /** Check if an event can travel upstream.
   */
  bool is_upstream() const;

  /** Get the Gst::EventType of the event.
   */
  _MEMBER_GET(event_type, type, EventType, GstEventType)

  /** Get the Gst::ClockTime timestamp of the event. This is the time when the
   * event was created.
   */
  _MEMBER_GET(timestamp, timestamp, ClockTime, guint64)

};

//TODO: Modify create methods of derived Event classes to return
//Glib::RefPtr<...> to the derived class and not just Gst::Event. Must deal
//with GstStructure immutability problem (bug #510301) first because casting
//Glib::RefPtrs references the objects which causes problems when GStreamer API
//tries to modify the GstStructures of the objects.

/** A flush start event.  See create() for more details.
 */
class EventFlushStart : public Event
{
};

/**  A flush stop event.  See create() for more details.
 */
class EventFlushStop : public Event
{

};

/** An end of stream event. See create() for more details.
 */
class EventEos : public Event
{

};

/** A new segment event.  See create() for more details.
 */
class EventNewSegment : public Event
{
public:


};

/** A tag event.
 */
class EventTag : public Event
{
public:
  /** Generates a metadata tag event from the given taglist.
   * @param taglist Metadata list.
   * @return A new Gst::Event.
   */
  static Glib::RefPtr<Gst::EventTag> create(const Gst::TagList& taglist);

  /** Parses a tag event and stores the results in the given taglist location.
   * @return Metadata list.
   */
  Gst::TagList parse() const;
  _IGNORE(gst_event_parse_tag)
};

/** A buffer size event.  See create() for more details.
 */
class EventBufferSize : public Event
{
public:
  explicit EventBufferSize(GstEvent* event);

  /** Create a new buffersize event. The event is sent downstream and notifies
   * elements that they should provide a buffer of the specified dimensions.
   *
   * When the async flag is set, a thread boundary is prefered.
   *
   * @param format Buffer format.
   * @param minsize Minimum buffer size.
   * @param maxsize Maximum buffer size.
   * @param async Thread behavior.
   * @return A new Gst::EventBufferSize.
   */
  static Glib::RefPtr<Gst::EventBufferSize>
    create(Format format, gint64 minsize, gint64 maxsize, bool async);

  /** Get the format, minsize, maxsize and async-flag in the buffersize event.
   *
   * @param format A reference to store the format in.
   * @param minsize A reference to store the minsize in.
   * @param maxsize A reference to store the maxsize in.
   * @param async A reference to store the async-flag in.
   */
  void parse(Format& format, gint64& minsize, gint64& maxsize, bool& async)
    const;
  _IGNORE(gst_event_parse_buffer_size)

  /** Get the minsize in the buffersize event.
   *
   * @return The mininum size.
   */
  gint64 parse() const;

  /** Get the format, in the buffersize event.
   *
   * @return The format.
   */
  Gst::Format parse_format() const;

  /** Get the maxsize in the buffersize event.
   *
   * @return The maximum size.
   */
  gint64 parse_max_size() const;

  /** Get the async-flag in the buffersize event.
   *
   * @return The async flag.
   */
  bool parse_async() const;
};

/** A QOS event.  See create() for more details.
 */
class EventQos : public Event
{
public:


  /** Get the proportion, diff and timestamp in the qos event. See create() for
   * more information about the different QoS values.
   *
   * @param proportion A reference to store the proportion in.
   * @param diff A reference to store the diff in.
   * @param timestamp A reference to store the timestamp in.
   */
  void parse(QOSType& type, double& proportion, ClockTimeDiff& diff, ClockTime& timestamp) const;
  _IGNORE(gst_event_parse_qos)

  /** Get the proportion in the qos event. See create() for more information
   * about the different QoS values.
   *
   * @return The proportion.
   */
  double parse() const;

  /** Get the diff in the qos event. See create() for more information about
   * the different QoS values.
   *
   * @return The difference.
   */
  ClockTimeDiff parse_diff() const;

  /** Get the timestamp in the qos event. See create() for more information
   * about the different QoS values.
   * @return The timestamp.
   */
  ClockTime parse_timestamp() const;
};

/** A seek event.  See create() for more details.
 */
class EventSeek : public Event
{
public:

  /** Parses a seek event and stores the results in the given result locations.
   *
   * @param rate Result location for the rate.
   * @param format Result location for the stream format.
   * @param flags Result location for the Gst::SeekFlags.
   * @param start_type Result location for the Gst::SeekType of the start
   * position.
   * @param start Result location for the start postion expressed in format.
   * @param stop_type Result location for the Gst::SeekType of the stop
   * position.
   * @param stop Result location for the stop postion expressed in format.
   */
  void parse(double& rate, Format& format, SeekFlags& flags,
    SeekType& start_type, gint64& start, SeekType& stop_type,
    gint64& stop) const;
  _IGNORE(gst_event_parse_seek)

  /** Parses the start of a seek event.
   * @return The start.
   */
  gint64 parse() const;

  /** Parses the rate of a seek event.
   * @return The rate.
   */
  double parse_rate() const;

  /** Parses the format of a seek event.
   * @return The format.
   */
  Format parse_format() const;

  /** Parses the flags of a seek event.
   * @return The flags.
   */
  SeekFlags parse_flags() const;

  /** Parses the start type of a seek event.
   * @return The start type.
   */
  SeekType parse_start_type() const;

  /** Parses the stop type of a seek event.
   * @return The stop type.
   */
  SeekType parse_stop_type() const;

  /** Parses the stop of a seek event.
   * @param The stop.
   */
  gint64 parse_stop() const;
};

/** A Navigation event.  See create() for more details.
 */
class EventNavigation : public Event
{
public:
};

/** A latency event.  See create() for more details.
 */
class EventLatency : public Event
{
public:
  explicit EventLatency(GstEvent* event);

  /** Create a new latency event. The event is sent upstream from the sinks and
   * notifies elements that they should add an additional latency to the
   * timestamps before synchronising against the clock.
   *
   * The latency is mostly used in live sinks and is always expressed in the
   * time format.
   *
   * @param latency The new latency value.
   * @return A new Gst::EventLatency.
   *
   * Since 0.10.12.
   */
  static Glib::RefPtr<Gst::EventLatency> create(ClockTime latency);

  /** Get the latency in the latency event.
   *
   * @return The latency. 
   */
  ClockTime parse() const;
  _IGNORE(gst_event_parse_latency)
};

/** A step event.  See create() for more details.
 */
class EventStep : public Event
{
public:


  /** Parse the step event.
   *
   * @param format A reference to store the format in.
   * @param amount A reference to store the amount in.
   * @param rate A reference to store the rate in.
   * @param flush A reference to store the flush boolean in.
   * @param intermediate A reference to store the intermediate boolean in.
   */
  void parse(Gst::Format& format, guint64& amount, double& rate,
    bool& flush, bool& intermediate) const;
  _IGNORE(gst_event_parse_step)

  /** Get the amount in a step event.
   * @return The amount.
   */
  guint64 parse() const;

  /** Get the format in a step event.
   * @return The format.
   */
  Gst::Format parse_format() const;

  /** Get the rate in a step event.
   * @return The rate.
   */
  double parse_rate() const;

  /** Get the flush in a step event.
   * @return The flush flag.
   */
  bool parse_flush() const;

  /** Get the intermediate flag in a step event.
   * @return The intermediate flag.
   */
  bool parse_intermediate() const;
};

/** A sink-message event.  See create() for more details.
 */
class EventSinkMessage : public Event
{
public:

};

} //namespace Gst
