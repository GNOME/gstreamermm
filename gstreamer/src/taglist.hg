// -*- Mode: C++; indent-tabs-mode: nil; c-basic-offset: 2 -*-

/* gstreamermm - a C++ wrapper for gstreamer
 *
 * Copyright 2008 The gstreamermm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gst/gsttaglist.h>
#include <gstreamermm/structure.h>

_DEFS(gstreamermm,gst)

namespace Gst
{

_WRAP_ENUM(TagMergeMode, GstTagMergeMode)
_WRAP_ENUM(TagFlag, GstTagFlag)

namespace Tag
{

/** Commonly used title (string).
 * The title as it should be displayed, e.g. 'The Doll House'.
 */
const Glib::ustring TITLE = GST_TAG_TITLE;

/** Commonly used title, as used for sorting (string).
 * The title as it should be sorted, e.g. 'Doll House, The'.
 *
 * Since 0.10.15.
 */
const Glib::ustring TITLE_SORTNAME = GST_TAG_TITLE_SORTNAME;

/** Person(s) responsible for the recording (string).
 * The artist name as it should be displayed, e.g. 'Jimi Hendrix' or 'The
 * Guitar Heroes'.
 */
const Glib::ustring ARTIST = GST_TAG_ARTIST;

/** Person(s) responsible for the recording, as used for sorting (string).
 * The artist name as it should be sorted, e.g. 'Hendrix, Jimi' or 'Guitar
 * Heroes, The'.
 *
 * Since 0.10.15.
 */
const Glib::ustring ARTIST_SORTNAME = GST_TAG_ARTIST_SORTNAME;

/** Album containing this data (string).
 * The album name as it should be displayed, e.g. 'The Jazz Guitar'.
 */
const Glib::ustring ALBUM = GST_TAG_ALBUM;

/** Album containing this data, as used for sorting (string).
 * The album name as it should be sorted, e.g. 'Jazz Guitar, The'.
 *
 * Since 0.10.15.
 */
const Glib::ustring ALBUM_SORTNAME = GST_TAG_ALBUM_SORTNAME;

/** Date the data was created (GDate structure).
 */
const Glib::ustring DATE = GST_TAG_DATE;

/** Genre this data belongs to (string).
 */
const Glib::ustring GENRE = GST_TAG_GENRE;

/** Free text commenting the data (string).
 */
const Glib::ustring COMMENT = GST_TAG_COMMENT;

/** Key/value text commenting the data (string).
 * Must be in the form of 'key=comment' or 'key[lc]=comment' where 'lc' is an
 * ISO-639 language code.
 *
 * This tag is used for unknown Vorbis comment tags, unknown APE tags and
 * certain ID3v2 comment fields.
 *
 * Since 0.10.10.
 */
const Glib::ustring EXTENDED_COMMENT = GST_TAG_EXTENDED_COMMENT;

/** Track number inside a collection (unsigned integer).
 */
const Glib::ustring TRACK_NUMBER = GST_TAG_TRACK_NUMBER;

/** Count of tracks inside collection this track belongs to (unsigned integer).
 */
const Glib::ustring TRACK_COUNT = GST_TAG_TRACK_COUNT;

/** Disc number inside a collection (unsigned integer).
 */
const Glib::ustring ALBUM_VOLUME_NUMBER = GST_TAG_ALBUM_VOLUME_NUMBER;

/** Count of discs inside collection this disc belongs to (unsigned integer).
 */
const Glib::ustring ALBUM_VOLUME_COUNT = GST_TAG_ALBUM_VOLUME_COUNT;

/** Original location of file as a URI (string).
 */
const Glib::ustring LOCATION = GST_TAG_LOCATION;

/** Short text describing the content of the data (string).
 */
const Glib::ustring DESCRIPTION = GST_TAG_DESCRIPTION;

/** Version of this data (string).
 */
const Glib::ustring VERSION = GST_TAG_VERSION;

/** International Standard Recording Code - see http://www.ifpi.org/isrc/
 * (string).
 */
const Glib::ustring ISRC = GST_TAG_ISRC;

/** Organization (string).
 */
const Glib::ustring ORGANIZATION = GST_TAG_ORGANIZATION;

/** Copyright notice of the data (string).
 */
const Glib::ustring COPYRIGHT = GST_TAG_COPYRIGHT;

/** URI to location where copyright details can be found (string).
 * Since 0.10.14.
 */
const Glib::ustring COPYRIGHT_URI = GST_TAG_COPYRIGHT_URI;

/** Person(s) who composed the recording (string).
 * Since 0.10.15.
 */
const Glib::ustring COMPOSER = GST_TAG_COMPOSER;

/** Contact information (string).
 */
const Glib::ustring CONTACT = GST_TAG_CONTACT;

/** License of data (string).
 */
const Glib::ustring LICENSE = GST_TAG_LICENSE;

/** URI to location where license details can be found (string).
 * Since 0.10.14.
 */
const Glib::ustring LICENSE_URI = GST_TAG_LICENSE_URI;

/** Person(s) performing (string).
 */
const Glib::ustring PERFORMER = GST_TAG_PERFORMER;

/** Length in GStreamer time units (nanoseconds) (unsigned 64-bit integer).
 */
const Glib::ustring DURATION = GST_TAG_DURATION;

/** Codec the data is stored in (string).
 */
const Glib::ustring CODEC = GST_TAG_CODEC;

/** Codec the video data is stored in (string).
 */
const Glib::ustring VIDEO_CODEC = GST_TAG_VIDEO_CODEC;

/** Codec the audio data is stored in (string).
 */
const Glib::ustring AUDIO_CODEC = GST_TAG_AUDIO_CODEC;

/** Exact or average bitrate in bits/s (unsigned integer).
 */
const Glib::ustring BITRATE = GST_TAG_BITRATE;

/** Nominal bitrate in bits/s (unsigned integer).
 */
const Glib::ustring NOMINAL_BITRATE = GST_TAG_NOMINAL_BITRATE;

/** Minimum bitrate in bits/s (unsigned integer).
 */
const Glib::ustring MINIMUM_BITRATE = GST_TAG_MINIMUM_BITRATE;

/** Maximum bitrate in bits/s (unsigned integer).
 */
const Glib::ustring MAXIMUM_BITRATE = GST_TAG_MAXIMUM_BITRATE;

/** Serial number of track (unsigned integer).
 */
const Glib::ustring SERIAL = GST_TAG_SERIAL;

/** Encoder used to encode this stream (string).
 */
const Glib::ustring ENCODER = GST_TAG_ENCODER;

/** Version of the encoder used to encode this stream (unsigned integer).
 */
const Glib::ustring ENCODER_VERSION = GST_TAG_ENCODER_VERSION;

/** Track gain in db (double).
 */
const Glib::ustring TRACK_GAIN = GST_TAG_TRACK_GAIN;

/** Peak of the track (double).
 */
const Glib::ustring TRACK_PEAK = GST_TAG_TRACK_PEAK;

/** Album gain in db (double).
 */
const Glib::ustring ALBUM_GAIN = GST_TAG_ALBUM_GAIN;

/** Peak of the album (double).
 */
const Glib::ustring ALBUM_PEAK = GST_TAG_ALBUM_PEAK;

/** Reference level of track and album gain values (double).
 * Since 0.10.12.
 */
const Glib::ustring REFERENCE_LEVEL = GST_TAG_REFERENCE_LEVEL;

/** Language code (ISO-639-1) (string) of the content.
 */
const Glib::ustring LANGUAGE_CODE = GST_TAG_LANGUAGE_CODE;

/** Image (buffer) (buffer caps should specify the content type and preferably
 * also set "image-type" field as GstTagImageType).
 * Since 0.10.6 
 */
const Glib::ustring IMAGE = GST_TAG_IMAGE;

/** Image that is meant for preview purposes, e.g. small icon-sized version
 * (buffer) (buffer caps should specify the content type).
 * Since 0.10.7.
 */
const Glib::ustring PREVIEW_IMAGE = GST_TAG_PREVIEW_IMAGE;

/** Number of beats per minute in audio (double).
 * Since 0.10.12.
 */
const Glib::ustring BEATS_PER_MINUTE = GST_TAG_BEATS_PER_MINUTE;

}

/** A List of tags and values used to describe media metadata.
 * Taglists form part of media streams and describe the content of a stream in
 * a non-technical way. Examples include the author of a song, the title of
 * that very same song or the album it is a part of. Tag reading is done
 * through a Gst::Bus. You can listen for Gst::MESSAGE_TAG messages and handle
 * them as you wish.
 *
 * Note, however, that the Gst::MESSAGE_TAG  message may be fired multiple
 * times in the pipeline. It is the application's responsibility to put all
 * those tags together and display them to the user in a nice, coherent way.
 * Usually, using merge() is a good enough way of doing this; make sure to
 * empty the cache when loading a new song, or after every few minutes when
 * listening to internet radio. Also, make sure you use Gst::TAG_MERGE_PREPEND
 * as merging mode, so that a new title (which came in later) has a preference
 * over the old one for display.
 */
class TagList : public Structure
{
  _CLASS_BOXEDTYPE_EXTRA(TagList, GstTagList, gst_tag_list_new, gst_tag_list_copy, gst_tag_list_free)
  _IGNORE(gst_tag_list_copy, gst_tag_list_free)

public:
  _WRAP_METHOD(static bool exists(const Glib::ustring& tag), gst_tag_exists)
  _WRAP_METHOD(static GType get_type(const Glib::ustring& tag), gst_tag_get_type)
  _WRAP_METHOD(static Glib::ustring get_nick(const Glib::ustring& tag), gst_tag_get_nick)
  _WRAP_METHOD(static Glib::ustring get_description(const Glib::ustring& tag), gst_tag_get_description)
  _WRAP_METHOD(static TagFlag get_flag(const Glib::ustring& tag), gst_tag_get_flag)
  _WRAP_METHOD(static bool is_fixed(const Glib::ustring& tag), gst_tag_is_fixed)
  _WRAP_METHOD(bool is_empty() const, gst_tag_list_is_empty)
  _WRAP_METHOD(void insert(const Gst::TagList& other, TagMergeMode mode=TAG_MERGE_PREPEND), gst_tag_list_insert)
  _WRAP_METHOD(Gst::TagList merge(const Gst::TagList& other, TagMergeMode mode=TAG_MERGE_PREPEND), gst_tag_list_merge)
  _WRAP_METHOD(guint size(const Glib::ustring& tag) const, gst_tag_list_get_tag_size)

  /** Sets a GValue for the given @a tag using the specified mode.
   *
   * @param tag The tag name.
   * @param mode The mode to use.
   * @param value The GValue to set.
   */
  void add(const Glib::ustring& tag, const Glib::ValueBase& value, TagMergeMode mode=TAG_MERGE_PREPEND);

  /** Sets the value for the given tag to string @a data using the specified
   * mode.
   *
   * @param tag The tag name.
   * @param data A string to which the tag should be set to.
   * @param mode The merge mode to use.
   */
  void add(const Glib::ustring& tag, const char* data, TagMergeMode mode=TAG_MERGE_PREPEND);

  /** Sets the value for the given tag using the specified mode.
   *
   * @param tag The tag name.
   * @param data A value which the tag should be set to (this can be any
   * supported C++ type).
   * @param mode The merge mode to use.
   */
  template <class DataType>
  void add(const Glib::ustring& tag, const DataType& data, TagMergeMode mode=TAG_MERGE_PREPEND);
  _IGNORE(gst_tag_list_add_valist, gst_tag_list_add_valist_values)

  _WRAP_METHOD(void remove_tag(const Glib::ustring& tag), gst_tag_list_remove_tag)

  /** For example,
   * void on_foreach(const Glib::ustring& tag);.
   */
  typedef sigc::slot<void, const Glib::ustring&> SlotForeach;

  /** Calls the given slot for each tag inside the tag list. Note that if there
   * is no tag, the slot won't be called at all.
   *
   * @param slot Slot to be called for each tag.
   */
  void foreach(const SlotForeach& slot);
  _IGNORE(gst_tag_list_foreach)

  /** Copies the contents for the given tag into the value, merging multiple
   * values into one if multiple values are associated with the tag.
   *
   * @param dest An uninitialized Glib::ValueBase to copy into.
   * @param tag The tag to read out.
   * @return true, if a value was copied, false if the tag didn't exist in the
   * list.
   */
  bool get(const Glib::ustring& tag, Glib::ValueBase& dest);
  _IGNORE(gst_tag_list_copy_value)

  /** Gets the value that is at the given index for the given tag.

   * @param tag The tag to read out.
   * @param index Number of entry to read out.
   * @@param The Glib::ValueBase to store the value in.
   * @return true if tag was available and had right number of entries, false
   * otherwise.
   */
  bool get(const Glib::ustring& tag, guint index, Glib::ValueBase& dest);
  _IGNORE(gst_tag_list_get_value_index)

  /** Copies the contents for the given tag into the value, merging multiple
   * values into one if multiple values are associated with the tag.
   * @param tag The tag to read out.
   * @param value Location for the result (this can be any supported C++ type).
   * @return true, if a value was copied, false if the tag didn't exist in the
   * given list.
   */
  template<class DataType> bool get(const Glib::ustring& tag, DataType& value);
  _IGNORE(gst_tag_list_get_char,
          gst_tag_list_get_uchar,
          gst_tag_list_get_boolean,
          gst_tag_list_get_int,
          gst_tag_list_get_uint,
          gst_tag_list_get_long, gst_tag_list_get_int64,
          gst_tag_list_get_ulong, gst_tag_list_get_uint64,
          gst_tag_list_get_float,
          gst_tag_list_get_double,
          gst_tag_list_get_string,
          gst_tag_list_get_date)

  /** Gets the value that is at the given index for the given tag.
   * @param tag The tag to read out.
   * @param index Number of entry to read out.
   * @param value Location for the result (this can be any supported C++ type).
   * @return true, if a value was copied, false if the tag didn't exist in the
   * given list.
   */
  template<class DataType> bool get(const Glib::ustring& tag, guint index, DataType& value);
  _IGNORE(gst_tag_list_get_char_index,
          gst_tag_list_get_uchar_index,
          gst_tag_list_get_boolean_index,
          gst_tag_list_get_int_index,
          gst_tag_list_get_uint_index,
          gst_tag_list_get_long_index, gst_tag_list_get_int64_index,
          gst_tag_list_get_ulong_index, gst_tag_list_get_uint64_index,
          gst_tag_list_get_float_index,
          gst_tag_list_get_double_index,
          gst_tag_list_get_string_index,
          gst_tag_list_get_date_index)

  //Variable argument functions are ignored.
  _IGNORE(gst_tag_list_add, gst_tag_list_add_values)
};

#ifndef DOXYGEN_SHOULD_SKIP_THIS

/***************************** Gst::TagList *****************************/

template <class DataType>
void TagList::add(const Glib::ustring& tag, const DataType& data, TagMergeMode mode)
{
  typedef Glib::Value<DataType> ValueType;

  ValueType value;
  value.init(ValueType::value_type());
  value.set(data);
  this->add(tag, (Glib::ValueBase) value, mode);
}

template<class DataType>
bool TagList::get(const Glib::ustring& tag, DataType& data)
{
  Glib::Value<DataType> value;
  bool result = this->get(tag, (Glib::ValueBase&) value);

  if (result)
    data = value.get();

  return result;
}

template<class DataType>
bool TagList::get(const Glib::ustring& tag, guint index, DataType& data)
{
  Glib::Value<DataType> value;
  bool result = this->get(tag, index, (Glib::ValueBase&) value);

  if (result)
    data = value.get();

  return result;
}

#endif /* DOXYGEN_SHOULD_SKIP_THIS */


} //namespace Gst
